var documenterSearchIndex = {"docs":
[{"location":"#GenomicBreedingModels","page":"Home","title":"GenomicBreedingModels","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GenomicBreedingModels.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#GenomicBreedingModels.LπDist","page":"Home","title":"GenomicBreedingModels.LπDist","text":"Laplace distribution with a point mass at 0.0\n\n\n\n\n\n","category":"type"},{"location":"#GenomicBreedingModels.NπDist","page":"Home","title":"GenomicBreedingModels.NπDist","text":"Gaussian distribution with a point mass at 0.0\n\n\n\n\n\n","category":"type"},{"location":"#GenomicBreedingModels.TπDist","page":"Home","title":"GenomicBreedingModels.TπDist","text":"T-distribution with a point mass at 0.0\n\n\n\n\n\n","category":"type"},{"location":"#Base.maximum-Tuple{GenomicBreedingModels.LπDist}","page":"Home","title":"Base.maximum","text":"Maximum value of the LπDist distribution\n\n\n\n\n\n","category":"method"},{"location":"#Base.maximum-Tuple{GenomicBreedingModels.NπDist}","page":"Home","title":"Base.maximum","text":"Maximum value of the NπDist distribution\n\n\n\n\n\n","category":"method"},{"location":"#Base.maximum-Tuple{GenomicBreedingModels.TπDist}","page":"Home","title":"Base.maximum","text":"Maximum value of the TπDist distribution\n\n\n\n\n\n","category":"method"},{"location":"#Base.minimum-Tuple{GenomicBreedingModels.LπDist}","page":"Home","title":"Base.minimum","text":"Minimum value of the LπDist distribution\n\n\n\n\n\n","category":"method"},{"location":"#Base.minimum-Tuple{GenomicBreedingModels.NπDist}","page":"Home","title":"Base.minimum","text":"Minimum value of the NπDist distribution\n\n\n\n\n\n","category":"method"},{"location":"#Base.minimum-Tuple{GenomicBreedingModels.TπDist}","page":"Home","title":"Base.minimum","text":"Minimum value of the TπDist distribution\n\n\n\n\n\n","category":"method"},{"location":"#Base.rand-Tuple{Random.AbstractRNG, GenomicBreedingModels.LπDist}","page":"Home","title":"Base.rand","text":"Sampling method for LπDist\n\nExamples\n\nd = LπDist(0.1, 0.0, 1.0)\nrand(d)\n\n\n\n\n\n","category":"method"},{"location":"#Base.rand-Tuple{Random.AbstractRNG, GenomicBreedingModels.NπDist}","page":"Home","title":"Base.rand","text":"Sampling method for NπDist\n\nExamples\n\nd = NπDist(0.1, 0.0, 1.0)\nrand(d)\n\n\n\n\n\n","category":"method"},{"location":"#Base.rand-Tuple{Random.AbstractRNG, GenomicBreedingModels.TπDist}","page":"Home","title":"Base.rand","text":"Sampling method for TπDist\n\nExamples\n\nd = TπDist(0.1, 1.0)\nrand(d)\n\n\n\n\n\n","category":"method"},{"location":"#Distributions.logpdf-Tuple{GenomicBreedingModels.LπDist, Real}","page":"Home","title":"Distributions.logpdf","text":"log(pdf) of LπDist\n\nExamples\n\nd = LπDist(0.1, 0.0, 1.0)\nlogpdf.(d, [-1.0, 0.0, 1.0])\n\n\n\n\n\n","category":"method"},{"location":"#Distributions.logpdf-Tuple{GenomicBreedingModels.NπDist, Real}","page":"Home","title":"Distributions.logpdf","text":"log(pdf) of NπDist\n\nExamples\n\nd = NπDist(0.1, 0.0, 1.0)\nlogpdf.(d, [-1.0, 0.0, 1.0])\n\n\n\n\n\n","category":"method"},{"location":"#Distributions.logpdf-Tuple{GenomicBreedingModels.TπDist, Real}","page":"Home","title":"Distributions.logpdf","text":"log(pdf) of TπDist\n\nExamples\n\nd = TπDist(0.1, 1.0)\nlogpdf.(d, [-1.0, 0.0, 1.0])\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.addnorm-Tuple{Any, Any}","page":"Home","title":"GenomicBreedingModels.addnorm","text":"addnorm(x, y) = (x + y) / 2.0\n\nThis function takes two numbers and finds their arithmetic mean. A member of the set of endofunctions defined in GenomicBreedingModels.jl for building non-linear genomic prediction models. Inputs and ouput range between zero and one.\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.bayesa-Tuple{}","page":"Home","title":"GenomicBreedingModels.bayesa","text":"bayesa(;\n    genomes::Genomes,\n    phenomes::Phenomes,\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    idx_trait::Int64 = 1,\n    n_iter::Int64 = 1_500,\n    n_burnin::Int64 = 500,\n    verbose::Bool = false\n)::Fit\n\nFits a Bayes A model for genomic prediction using the BGLR method. Bayes A assumes marker effects follow a scaled-t distribution, allowing for different variances for each marker effect.\n\nArguments\n\ngenomes::Genomes: Genomic data structure containing allele frequencies\nphenomes::Phenomes: Phenotypic data structure containing trait measurements\nidx_entries::Union{Nothing,Vector{Int64}}: Optional indices to subset specific entries/individuals\nidx_loci_alleles::Union{Nothing,Vector{Int64}}: Optional indices to subset specific genetic markers\nidx_trait::Int64: Index of the trait to analyze (default: 1)\nn_iter::Int64: Number of iterations for the MCMC algorithm (default: 1,500)\nn_burnin::Int64: Number of burn-in iterations to discard (default: 500)\nverbose::Bool: Whether to print progress messages (default: false)\n\nReturns\n\nFit: A fitted model object containing:\nmodel: Model identifier (\"ols\")\nb_hat: Estimated regression coefficients\nb_hat_labels: Labels for the coefficients\ntrait: Name of the analyzed trait\nentries: Entry identifiers\npopulations: Population identifiers\ny_true: Observed phenotypic values\ny_pred: Predicted phenotypic values\nmetrics: Dictionary of performance metrics\n\nNotes\n\nThe model assumes a Gaussian distribution for the trait values\nRecommended to check convergence by examining trace plots of key parameters\nThe burn-in period should be adjusted based on convergence diagnostics\n\nExamples\n\njulia> genomes = GenomicBreedingCore.simulategenomes(verbose=false);\n\njulia> trials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;\n\njulia> phenomes = extractphenomes(trials);\n\njulia> fit = bayesa(genomes=genomes, phenomes=phenomes);\n\njulia> fit.model == \"bayesa\"\ntrue\n\njulia> fit.metrics[\"cor\"] > 0.50\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.bayesb-Tuple{}","page":"Home","title":"GenomicBreedingModels.bayesb","text":"bayesb(;\n    genomes::Genomes,\n    phenomes::Phenomes,\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    idx_trait::Int64 = 1,\n    n_iter::Int64 = 1_500,\n    n_burnin::Int64 = 500,\n    verbose::Bool = false\n)::Fit\n\nFits a Bayes B model for genomic prediction using the BGLR method. Bayes B assumes that marker effects follow a mixture distribution where some markers have zero effect and others follow a scaled-t distribution.\n\nArguments\n\ngenomes::Genomes: Genomic data structure containing allele frequencies\nphenomes::Phenomes: Phenotypic data structure containing trait measurements\nidx_entries::Union{Nothing,Vector{Int64}}: Optional indices to subset specific entries (default: nothing)\nidx_loci_alleles::Union{Nothing,Vector{Int64}}: Optional indices to subset specific loci/alleles (default: nothing)\nidx_trait::Int64: Index of the trait to analyze (default: 1)\nn_iter::Int64: Number of iterations for the MCMC algorithm (default: 1,500)\nn_burnin::Int64: Number of burn-in iterations to discard (default: 500)\nverbose::Bool: Whether to print progress information (default: false)\n\nReturns\n\nFit: A fitted model object containing:\nmodel: Model identifier (\"ols\")\nb_hat: Estimated regression coefficients\nb_hat_labels: Labels for the coefficients\ntrait: Name of the analyzed trait\nentries: Entry identifiers\npopulations: Population identifiers\ny_true: Observed phenotypic values\ny_pred: Predicted phenotypic values\nmetrics: Dictionary of performance metrics\n\nExamples\n\njulia> genomes = GenomicBreedingCore.simulategenomes(verbose=false);\n\njulia> trials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;\n\njulia> phenomes = extractphenomes(trials);\n\njulia> fit = bayesb(genomes=genomes, phenomes=phenomes);\n\njulia> fit.model == \"bayesb\"\ntrue\n\njulia> fit.metrics[\"cor\"] > 0.50\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.bayesc-Tuple{}","page":"Home","title":"GenomicBreedingModels.bayesc","text":"bayesc(;\n    genomes::Genomes,\n    phenomes::Phenomes,\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    idx_trait::Int64 = 1,\n    n_iter::Int64 = 1_500,\n    n_burnin::Int64 = 500,\n    verbose::Bool = false\n)::Fit\n\nFits a Bayes C model for genomic prediction using the BGLR method. Bayes C assumes that marker effects follow  a mixture distribution with a point mass at zero and a normal distribution.\n\nArguments\n\ngenomes::Genomes: Genomic data structure containing allele frequencies\nphenomes::Phenomes: Phenotypic data structure containing trait measurements\nidx_entries::Union{Nothing,Vector{Int64}}: Optional indices to subset specific entries/individuals\nidx_loci_alleles::Union{Nothing,Vector{Int64}}: Optional indices to subset specific loci/alleles\nidx_trait::Int64: Index of the trait to analyze (default: 1)\nn_iter::Int64: Number of iterations for MCMC sampling (default: 1,500)\nn_burnin::Int64: Number of burn-in iterations to discard (default: 500)\nverbose::Bool: Whether to print progress information (default: false)\n\nReturns\n\nFit: A fitted model object containing:\nmodel: Model identifier (\"ols\")\nb_hat: Estimated regression coefficients\nb_hat_labels: Labels for the coefficients\ntrait: Name of the analyzed trait\nentries: Entry identifiers\npopulations: Population identifiers\ny_true: Observed phenotypic values\ny_pred: Predicted phenotypic values\nmetrics: Dictionary of performance metrics\n\nExamples\n\njulia> genomes = GenomicBreedingCore.simulategenomes(verbose=false);\n\njulia> trials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;\n\njulia> phenomes = extractphenomes(trials);\n\njulia> fit = bayesc(genomes=genomes, phenomes=phenomes);\n\njulia> fit.model == \"bayesc\"\ntrue\n\njulia> fit.metrics[\"cor\"] > 0.50\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.bayesian-Tuple{Function}","page":"Home","title":"GenomicBreedingModels.bayesian","text":"bayesian(\n    turing_model::Function;\n    X::Matrix{Float64},\n    y::Vector{Float64},\n    sampler::String = [\"NUTS\", \"HMC\", \"HMCDA\", \"MH\", \"PG\"][1],\n    sampling_method::Int64 = 1,\n    seed::Int64 = 123,\n    n_burnin::Int64 = 500,\n    n_iter::Int64 = 1_500,\n    verbose::Bool = false,\n)::Fit\n\nFit a Bayesian linear regression models via Turing.jl\n\nExamples\n\njulia> genomes = GenomicBreedingCore.simulategenomes(verbose=false);\n\njulia> trials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);\n\njulia> phenomes = extractphenomes(trials);\n\njulia> sol = Suppressor.@suppress bayesian(turing_bayesG, genomes=genomes, phenomes=phenomes);\n\njulia> # Slow because not multivariate T-dist: sol_T = Suppressor.@suppress bayesian(turing_bayesT, genomes=genomes, phenomes=phenomes);\n\njulia> # Even slower because of an extra set of distribution to define a non-spherical variance-covariance matrix: sol_Gs = Suppressor.@suppress bayesian(turing_bayesGs, genomes=genomes, phenomes=phenomes);\n\njulia> sol_BGLR = Suppressor.@suppress bayesian(\"BayesA\", genomes=genomes, phenomes=phenomes); sol.metrics[\"cor\"] > sol_BGLR.metrics[\"cor\"]\ntrue\n\njulia> sol.metrics[\"cor\"] > 0.5\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.bayesian-Tuple{String}","page":"Home","title":"GenomicBreedingModels.bayesian","text":"bayesian(\n    bglr_model::String;\n    genomes::Genomes,\n    phenomes::Phenomes,\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    idx_trait::Int64 = 1,\n    response_type::String = [\"gaussian\", \"ordinal\"][1], \n    n_burnin::Int64 = 500,\n    n_iter::Int64 = 1_500, \n    verbose::Bool = false\n)::Fit\n\nFit Bayesian genomic prediction models using the BGLR R package.\n\nArguments\n\nbglr_model::String: Type of BGLR model to fit. Options: \"BayesA\", \"BayesB\", \"BayesC\"\ngenomes::Genomes: Genomic data structure containing allele frequencies\nphenomes::Phenomes: Phenotypic data structure containing trait measurements\nidx_entries::Union{Nothing,Vector{Int64}}: Optional indices to subset entries \nidx_loci_alleles::Union{Nothing,Vector{Int64}}: Optional indices to subset loci/alleles\nidx_trait::Int64: Index of trait to analyze (default: 1)\nresponse_type::String: Type of response variable. Options: \"gaussian\" or \"ordinal\" (default: \"gaussian\")\nn_burnin::Int64: Number of burn-in MCMC iterations (default: 500)\nn_iter::Int64: Total number of MCMC iterations (default: 1,500)\nverbose::Bool: Whether to print progress information (default: false)\n\nReturns\n\nFit: Object containing:\nModel fit summary\nEstimated genetic effects\nPredicted values  \nModel performance metrics\nInput data details\n\nDetails\n\nThis function provides a Julia interface to the BGLR R package for Bayesian genomic prediction. It uses temporary files to interface with R and automatically cleans up afterward.\n\nExamples\n\njulia> genomes = GenomicBreedingCore.simulategenomes(verbose=false);\n\njulia> trials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);\n\njulia> phenomes = extractphenomes(trials);\n\njulia> sol = Suppressor.@suppress bayesian(\"BayesA\", genomes=genomes, phenomes=phenomes);\n\njulia> sol.metrics[\"cor\"] > 0.5\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.bglr-Tuple{}","page":"Home","title":"GenomicBreedingModels.bglr","text":"bglr(; G::Matrix{Float64}, y::Vector{Float64}, model::String=\"BayesA\", \n     response_type::String=\"gaussian\", n_iter::Int64=1_500, \n     n_burnin::Int64=500, verbose::Bool=false)::Vector{Float64}\n\nPerform Bayesian genomic prediction using the BGLR (Bayesian Generalized Linear Regression) R package.\n\nArguments\n\nG::Matrix{Float64}: Marker matrix where rows represent individuals and columns represent locus-allele combinations\ny::Vector{Float64}: Vector of phenotypic values\nmodel::String: Bayesian model type to use. Options: \"BayesA\", \"BayesB\", or \"BayesC\". Default: \"BayesA\"\nresponse_type::String: Type of response variable. Options: \"gaussian\" or \"ordinal\". Default: \"gaussian\"\nn_iter::Int64: Number of iterations for the MCMC chain. Default: 1,500\nn_burnin::Int64: Number of burn-in iterations to discard. Default: 500\nverbose::Bool: Whether to print progress information. Default: false\n\nReturns\n\nVector{Float64}: Estimated effects including the intercept (first element) followed by marker effects\n\nDetails\n\nThis function creates temporary files to interface with R's BGLR package, runs the Bayesian analysis, and automatically cleans up temporary files afterward. The function uses the system's R installation  and requires the BGLR package to be installed in R.\n\nNotes\n\nThis is hacky. It invokes Rscript for each instance which should allow multithreading because RCall.jl currently does not allow multithreading.\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.cvbulk-Tuple{}","page":"Home","title":"GenomicBreedingModels.cvbulk","text":"cvbulk(;\n    genomes::Genomes,\n    phenomes::Phenomes,\n    models::Vector{Function}=[ridge],\n    n_replications::Int64=5,\n    n_folds::Int64=5,\n    seed::Int64=42,\n    verbose::Bool=true\n)::Tuple{Vector{CV}, Vector{String}}\n\nPerform replicated k-fold cross-validation of genomic prediction model(s) across all available traits and entries, ignoring populations.\n\nArguments\n\ngenomes::Genomes: Genomic data structure containing allele frequencies\nphenomes::Phenomes: Phenotypic data structure containing trait measurements\nmodels::Vector{Function}: Vector of genomic prediction model functions to evaluate\nn_replications::Int64: Number of times to repeat k-fold cross-validation randomising k-fold partitioning each time (default: 5)\nn_folds::Int64: Number of cross-validation folds (default: 5) \nseed::Int64: Random seed for reproducibility (default: 42)\nverbose::Bool: Whether to display progress information (default: true)\n\nReturns\n\nTuple containing:\nVector of CV objects with cross-validation results\nVector of warning messages about skipped cases\n\nThreading\n\nUses multiple threads if Julia is started with threading enabled. Example startup command: julia --threads 7,1 (7 worker threads, 1 runtime thread)\n\nNotes\n\nPerforms random k-fold partitioning of entries ignoring population structure\nHandles missing/invalid phenotype values\nValidates model inputs and data dimensions\nReturns warnings for cases with insufficient data or zero variance\n\nExample\n\njulia> genomes = GenomicBreedingCore.simulategenomes(verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> trials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, verbose=false);\n\njulia> phenomes = extractphenomes(trials);\n\njulia> cvs, notes = cvbulk(genomes=genomes, phenomes=phenomes, models=[ols, ridge], n_replications=2, n_folds=2, verbose=false);\n\njulia> df_across_entries, df_per_entry = tabularise(cvs);\n\njulia> idx_across = findall((df_across_entries.trait .== \"trait_1\") .&& (df_across_entries.model .== \"ridge\") .&& (df_across_entries.replication .== \"replication_1\") .&& (df_across_entries.fold .== \"fold_1\"));\n\njulia> idx_per = findall((df_per_entry.trait .== \"trait_1\") .&& (df_per_entry.model .== \"ridge\") .&& (df_per_entry.replication .== \"replication_1\") .&& (df_per_entry.fold .== \"fold_1\"));\n\njulia> abs(df_across_entries.cor[idx_across][1] - cor(df_per_entry.y_true[idx_per], df_per_entry.y_pred[idx_per])) < 1e-10\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.cvleaveonepopulationout-Tuple{}","page":"Home","title":"GenomicBreedingModels.cvleaveonepopulationout","text":"cvleaveonepopulationout(;\n    genomes::Genomes,\n    phenomes::Phenomes,\n    models::Vector{Function}=[ridge],\n    n_replications::Int64=5,\n    n_folds::Int64=5,\n    seed::Int64=42,\n    verbose::Bool=true\n)::Tuple{Vector{CV}, Vector{String}}\n\nPerforms leave-one-population-out cross-validation for genomic prediction models across all available traits.\n\nArguments\n\ngenomes::Genomes: Genomic data structure containing allele frequencies\nphenomes::Phenomes: Phenotypic data structure containing trait measurements\nmodels::Vector{Function}: Vector of model functions to evaluate (default: [ridge])\nn_replications::Int64: Number of replications (not used in this implementation)\nn_folds::Int64: Number of folds (not used in this implementation)\nseed::Int64: Random seed (not used in this implementation)\nverbose::Bool: If true, displays progress information during execution\n\nReturns\n\nTuple{Vector{CV}, Vector{String}}: Returns a tuple containing:\nVector of CV objects with cross-validation results\nVector of warning/error messages for skipped validations\n\nDetails\n\nThe function implements a leave-one-population-out cross-validation strategy where:\n\nFor each trait and population combination:\nUses one population as validation set\nUses remaining populations as training set\nEvaluates multiple genomic prediction models\nHandles missing data and variance checks\nSupports parallel processing via Julia's multi-threading\n\nThreading\n\nTo utilize multiple threads, start Julia with: julia --threads n,1 where n is the desired number of threads for computation and 1 is reserved for the runtime.\n\nSupported Models\n\nols (Ordinary Least Squares)\nridge (Ridge Regression)\nlasso (Lasso Regression)\nbayesa (Bayes A)\nbayesb (Bayes B)\nbayesc (Bayes C)\n\nExample\n\njulia> genomes = GenomicBreedingCore.simulategenomes(verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> trials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);\n\njulia> phenomes = extractphenomes(trials);\n\njulia> cvs, notes = cvleaveonepopulationout(genomes=genomes, phenomes=phenomes, models=[ridge, bayesa], n_replications=2, n_folds=2, verbose=false);\n\njulia> df_across_entries, df_per_entry = tabularise(cvs);\n\njulia> sum([sum(split(df_across_entries.training_population[i], \";\") .== df_across_entries.validation_population[i]) for i in 1:size(df_across_entries, 1)]) == 0\ntrue\n\njulia> idx_across = findall((df_across_entries.validation_population .== \"pop_1\") .&& (df_across_entries.trait .== \"trait_1\") .&& (df_across_entries.model .== \"ridge\"));\n\njulia> idx_per = findall((df_per_entry.validation_population .== \"pop_1\") .&& (df_per_entry.trait .== \"trait_1\") .&& (df_per_entry.model .== \"ridge\"));\n\njulia> abs(df_across_entries.cor[idx_across][1] - cor(df_per_entry.y_true[idx_per], df_per_entry.y_pred[idx_per])) < 1e-10\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.cvmultithread!-Tuple{Vector{GenomicBreedingCore.CV}}","page":"Home","title":"GenomicBreedingModels.cvmultithread!","text":"cvmultithread!(cvs::Vector{CV}; genomes::Genomes, phenomes::Phenomes, models_vector, verbose::Bool = true)::Vector{CV}\n\nPerform multi-threaded genomic prediction cross-validation using specified models.\n\nArguments\n\ncvs::Vector{CV}: Vector of cross-validation objects to be processed\ngenomes::Genomes: Genomic data structure containing allele frequencies\nphenomes::Phenomes: Phenotypic data structure containing trait measurements\nmodels_vector: Vector of model functions to be used for prediction (e.g., [ridge, bayesa])\nverbose::Bool=true: Whether to display progress bar during computation\n\nReturns\n\nModified cvs vector with updated cross-validation results\n\nThreading\n\nRequires Julia to be started with multiple threads to utilize parallel processing. Example startup command: julia --threads 7,1 (7 worker threads, 1 runtime thread)\n\nDetails\n\nThe function performs cross-validation in parallel for each CV object using the corresponding model from the models_vector. For each fold:\n\nExtracts training and validation indices\nFits the specified model using training data\nValidates the model using validation data\nUpdates the CV object with prediction results\n\nExample\n\njulia> genomes = GenomicBreedingCore.simulategenomes(verbose=false);\n\njulia> trials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);\n\njulia> phenomes = extractphenomes(trials);\n\njulia> idx_training = collect(1:50);\n\njulia> idx_validation_1 = collect(51:75);\n\njulia> idx_validation_2 = collect(76:100);\n\njulia> fit = Fit(n = length(idx_training), l = length(genomes.loci_alleles) + 1); fit.model = \"ridge\"; fit.trait = \"trait_1\"; \n\njulia> fit.entries = genomes.entries[idx_training]; fit.populations = genomes.populations[idx_training]; \n\njulia> fit.b_hat_labels = vcat([\"intercept\"], genomes.loci_alleles);\n\njulia> cv_1 = CV(\"replication_1\", \"fold_1\", fit, genomes.populations[idx_validation_1], genomes.entries[idx_validation_1], zeros(length(idx_validation_1)), zeros(length(idx_validation_1)), fit.metrics);\n\njulia> cv_2 = CV(\"replication_1\", \"fold_2\", fit, genomes.populations[idx_validation_2], genomes.entries[idx_validation_2], zeros(length(idx_validation_2)), zeros(length(idx_validation_2)), fit.metrics);\n\njulia> cvs = [cv_1, cv_2]; models = [ridge, ridge];\n\njulia> cvmultithread!(cvs, genomes=genomes, phenomes=phenomes, models_vector=[ridge, bayesa], verbose=false);\n\njulia> df_across_entries, df_per_entry = tabularise(cvs);\n\njulia> idx_across = findall(df_across_entries.fold .== \"fold_2\");\n\njulia> idx_per = findall(df_per_entry.fold .== \"fold_2\");\n\njulia> abs(df_across_entries.cor[idx_across][1] - cor(df_per_entry.y_true[idx_per], df_per_entry.y_pred[idx_per])) < 1e-10\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.cvpairwisepopulation-Tuple{}","page":"Home","title":"GenomicBreedingModels.cvpairwisepopulation","text":"cvpairwisepopulation(;\n    genomes::Genomes,\n    phenomes::Phenomes,\n    models::Vector{Function}=[ridge],\n    n_replications::Int64=5,\n    n_folds::Int64=5, \n    seed::Int64=42,\n    verbose::Bool=true\n)::Tuple{Vector{CV}, Vector{String}}\n\nPerforms pairwise cross-validation between populations for genomic prediction models.\n\nArguments\n\ngenomes::Genomes: Genomic data structure containing allele frequencies\nphenomes::Phenomes: Phenotypic data structure containing trait measurements\nmodels::Vector{Function}: Vector of genomic prediction model functions to evaluate (default: [ridge])\nn_replications::Int64: Number of replications (unused, maintained for API consistency)\nn_folds::Int64: Number of folds (unused, maintained for API consistency)  \nseed::Int64: Random seed (unused, maintained for API consistency)\nverbose::Bool: Whether to display progress information\n\nReturns\n\nTuple{Vector{CV}, Vector{String}}: \nVector of CV objects containing cross-validation results\nVector of warning messages for skipped validations\n\nDetails\n\nFor each pair of populations (pop1, pop2):\n\nUses pop1 as training set and pop2 as validation set\nSkips within-population validation (pop1==pop2)\nEvaluates each model on all available traits\nHandles missing/invalid phenotype values\nValidates model inputs and data dimensions\n\nThreading\n\nRequires Julia to be started with multiple threads: julia --threads n,1 where n is number of worker threads\n\nExamples\n\njulia> genomes = GenomicBreedingCore.simulategenomes(verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> trials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);\n\njulia> phenomes = extractphenomes(trials);\n\njulia> cvs, notes = cvpairwisepopulation(genomes=genomes, phenomes=phenomes, models=[ols, ridge], n_replications=2, n_folds=2, verbose=false);\n\njulia> df_across_entries, df_per_entry = tabularise(cvs);\n\njulia> sum(df_across_entries.training_population .!= df_across_entries.validation_population) == size(df_across_entries, 1)\ntrue\n\njulia> idx_across = findall((df_across_entries.training_population .== \"pop_1\") .&& (df_across_entries.validation_population .== \"pop_2\") .&& (df_across_entries.trait .== \"trait_1\") .&& (df_across_entries.model .== \"ridge\"));\n\njulia> idx_per = findall((df_per_entry.training_population .== \"pop_1\") .&& (df_per_entry.validation_population .== \"pop_2\") .&& (df_per_entry.trait .== \"trait_1\") .&& (df_per_entry.model .== \"ridge\"));\n\njulia> abs(df_across_entries.cor[idx_across][1] - cor(df_per_entry.y_true[idx_per], df_per_entry.y_pred[idx_per])) < 1e-10\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.cvperpopulation-Tuple{}","page":"Home","title":"GenomicBreedingModels.cvperpopulation","text":"cvperpopulation(;\n    genomes::Genomes,\n    phenomes::Phenomes,\n    models::Vector{Function}=[ridge],\n    n_replications::Int64=5,\n    n_folds::Int64=5,\n    seed::Int64=42,\n    verbose::Bool=true\n)::Tuple{Vector{CV}, Vector{String}}\n\nPerforms within-population replicated cross-validation of genomic prediction models across all available traits.\n\nArguments\n\ngenomes::Genomes: Genomic data structure containing allele frequencies\nphenomes::Phenomes: Phenotypic data structure containing trait measurements\nmodels::Vector{Function}=[ridge]: Vector of genomic prediction model functions to evaluate\nn_replications::Int64=5: Number of replications for cross-validation\nn_folds::Int64=5: Number of folds for k-fold cross-validation\nseed::Int64=42: Random seed for reproducibility\nverbose::Bool=true: Whether to print progress information\n\nReturns\n\nTuple{Vector{CV}, Vector{String}}: A tuple containing:\nVector of CV objects with cross-validation results\nVector of notes/warnings generated during the process\n\nDetails\n\nThe function performs separate cross-validations for each unique population in the dataset. Supports multiple genomic prediction models including:\n\nols: Ordinary Least Squares\nridge: Ridge Regression\nlasso: Lasso Regression\nbayesa: Bayes A\nbayesb: Bayes B\nbayesc: Bayes C\n\nThreading\n\nTo use multiple threads, invoke Julia with: julia --threads n,1 where n is the desired number of threads for multi-threaded processes and 1 is reserved for the Julia runtime.\n\nExamples\n\njulia> genomes = GenomicBreedingCore.simulategenomes(l=1_000, verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> trials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);\n\njulia> phenomes = extractphenomes(trials);\n\njulia> cvs, notes = cvperpopulation(genomes=genomes, phenomes=phenomes, models=[ridge, bayesa], n_replications=2, n_folds=2, verbose=false);\n\njulia> df_across_entries, df_per_entry = tabularise(cvs);\n\njulia> sort(unique(df_across_entries.training_population))\n3-element Vector{String}:\n \"pop_1\"\n \"pop_2\"\n \"pop_3\"\n\njulia> df_across_entries.training_population == df_across_entries.validation_population\ntrue\n\njulia> idx_across = findall((df_across_entries.validation_population .== \"pop_1\") .&& (df_across_entries.trait .== \"trait_1\") .&& (df_across_entries.model .== \"bayesa\") .&& (df_across_entries.replication .== \"replication_1\") .&& (df_across_entries.fold .== \"fold_1\"));\n\njulia> idx_per = findall((df_per_entry.validation_population .== \"pop_1\") .&& (df_per_entry.trait .== \"trait_1\") .&& (df_per_entry.model .== \"bayesa\") .&& (df_per_entry.replication .== \"replication_1\") .&& (df_per_entry.fold .== \"fold_1\"));\n\njulia> abs(df_across_entries.cor[idx_across][1] - cor(df_per_entry.y_true[idx_per], df_per_entry.y_pred[idx_per])) < 1e-10\ntrue\n\njulia> summary_across, summary_per_entry = summarise(cvs);\n\njulia> size(summary_across)\n(6, 8)\n\njulia> size(summary_per_entry)\n(200, 8)\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.epistasisfeatures-Tuple{GenomicBreedingCore.Genomes, GenomicBreedingCore.Phenomes}","page":"Home","title":"GenomicBreedingModels.epistasisfeatures","text":"epistasisfeatures(\n    genomes::Genomes,\n    phenomes::Phenomes;\n    idx_trait::Int64 = 1,\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    transformations1::Vector{Function} = [square, invoneplus, log10epsdivlog10eps],\n    transformations2::Vector{Function} = [mult, addnorm, raise],\n    n_new_features_per_transformation::Int64 = 1_000,\n    n_reps::Int64 = 3,\n    verbose::Bool = false\n)::Genomes\n\nGenerate epistasis features by applying various transformations to genomic data.\n\nArguments\n\ngenomes::Genomes: Genomic data structure containing allele frequencies\nphenomes::Phenomes: Phenotypic data structure containing trait measurements\nidx_trait::Int64: Index of the trait to analyze (default: 1)\nidx_entries::Union{Nothing,Vector{Int64}}: Indices of entries to include (default: all)\nidx_loci_alleles::Union{Nothing,Vector{Int64}}: Indices of loci/alleles to include (default: all)\ntransformations1::Vector{Function}: Single-input transformation functions (default: [square, invoneplus, log10epsdivlog10eps])\ntransformations2::Vector{Function}: Two-input transformation functions (default: [mult, addnorm, raise])\nn_new_features_per_transformation::Int64: Number of new features to generate per transformation (default: 1_000)\nn_reps::Int64: Number of times to repeat the transformation process (default: 3)\nverbose::Bool: Whether to display progress information (default:  false)\n\nReturns\n\nGenomes: Enhanced genomic data structure with additional epistasis features\n\nDescription\n\nThis function generates epistasis features by applying two types of transformations:\n\nSingle-input transformations (transformations1) applied to individual genomic features\nTwo-input transformations (transformations2) applied to pairs of genomic features\n\nThe transformations are repeated n_reps times to create a rich set of derived features.\n\nNotes\n\nEnsures all generated features are within [0,1] range\nMaintains dimensional consistency of input/output structures\nAutomatically handles entry and loci/allele subsetting\nValidates input data structures before processing\n\nExample\n\njulia> genomes = GenomicBreedingCore.simulategenomes(l=1_000, verbose=false);\n\njulia> trials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;\n\njulia> phenomes = extractphenomes(trials);\n\njulia> genomes_plus_features = epistasisfeatures(genomes, phenomes, n_new_features_per_transformation=50, n_reps=2, verbose=false);\n\njulia> cvs, notes = cvbulk(genomes=genomes_plus_features, phenomes=phenomes, models=[ridge, lasso, bayesa], verbose=false);\n\njulia> cvs_no_epi, notes_no_epi = cvbulk(genomes=genomes, phenomes=phenomes, models=[ridge, lasso, bayesa], verbose=false);\n\njulia> df_across, df_per_entry = GenomicBreedingCore.tabularise(cvs);\n\njulia> df_across_no_epi, df_per_entry_no_epi = GenomicBreedingCore.tabularise(cvs_no_epi);\n\njulia> df_summary = combine(groupby(df_across, [:trait, :model]), [[:cor] => mean, [:cor] => std]);\n\njulia> df_summary_no_epi = combine(groupby(df_across_no_epi, [:trait, :model]), [[:cor] => mean, [:cor] => std]);\n\njulia> mean(df_summary.cor_mean) > mean(df_summary_no_epi.cor_mean)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.extractxyetc-Tuple{GenomicBreedingCore.Genomes, GenomicBreedingCore.Phenomes}","page":"Home","title":"GenomicBreedingModels.extractxyetc","text":"extractxyetc(\n    genomes::Genomes,\n    phenomes::Phenomes;\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    idx_trait::Int64 = 1,\n    add_intercept::Bool = true\n) -> Tuple{Matrix{Float64}, Vector{Float64}, Vector{String}, Vector{String}, Vector{String}}\n\nExtract data matrices and vectors from genomic and phenotypic data for statistical analyses.\n\nArguments\n\ngenomes::Genomes: Genomic data structure containing allele frequencies\nphenomes::Phenomes: Phenotypic data structure containing trait measurements\nidx_entries::Union{Nothing,Vector{Int64}}: Optional indices to select specific entries (default: all entries)\nidx_loci_alleles::Union{Nothing,Vector{Int64}}: Optional indices to select specific loci-alleles (default: all loci-alleles)\nidx_trait::Int64: Index of the trait to analyze (default: 1)\nadd_intercept::Bool: Whether to add an intercept column to the design matrix (default: true)\n\nReturns\n\nA tuple containing:\n\nX::Matrix{Float64}: Design matrix with allele frequencies (and intercept if specified)\ny::Vector{Float64}: Response vector with phenotypic values\nentries::Vector{String}: Names of the selected entries\npopulations::Vector{String}: Population identifiers for the selected entries\nloci_alleles::Vector{String}: Names of the selected loci-alleles\n\nNotes\n\nThe function filters out entries with missing, NaN, or infinite phenotype values\nRequires at least 2 valid entries after filtering\nChecks for non-zero variance in the trait values\nEnsures consistency between genomic and phenotypic data dimensions\nValidates all index inputs are within bounds\n\nExamples\n\njulia> genomes = GenomicBreedingCore.simulategenomes(verbose=false);\n\njulia> trials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;\n\njulia> phenomes = extractphenomes(trials);\n\njulia> X, y, loci_alleles = extractxyetc(genomes, phenomes);\n\njulia> X == hcat(ones(length(phenomes.entries)), genomes.allele_frequencies)\ntrue\n\njulia> y == phenomes.phenotypes[:, 1]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.gwaslmm-Tuple{}","page":"Home","title":"GenomicBreedingModels.gwaslmm","text":"gwaslmm(\n    genomes::Genomes,\n    phenomes::Phenomes;\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    idx_trait::Int64 = 1,\n    GRM_type::String = [\"simple\", \"ploidy-aware\"][1],\n    verbose::Bool = false\n)::Fit\n\nPerform genome-wide association analysis using a linear mixed model (LMM) approach.\n\nArguments\n\ngenomes::Genomes: Genomic data structure containing allele frequencies\nphenomes::Phenomes: Phenotypic data structure containing trait measurements\nidx_entries::Union{Nothing,Vector{Int64}}: Optional indices for subsetting entries\nidx_loci_alleles::Union{Nothing,Vector{Int64}}: Optional indices for subsetting loci/alleles\nidx_trait::Int64: Index of the trait to analyze (default: 1)\nGRM_type::String: Type of genetic relationship matrix to use:\n\"simple\": Standard GRM calculation\n\"ploidy-aware\": Ploidy-adjusted GRM calculation\nverbose::Bool: Whether to display progress and plots (default: false)\n\nReturns\n\nFit: A structure containing GWAS results including:\nmodel: Model identifier (\"GWAS_LMM\")\nb_hat: Vector of test statistics (z-scores) for genetic markers\n\nDetails\n\nThe function implements a mixed model GWAS using the first principal component of the genetic  relationship matrix (GRM) as a fixed effect to control for population structure. The model  includes random effects for entries and uses REML estimation.\n\nNotes\n\nHandles both diploid and polyploid data through the GRM_type parameter\nUses multi-threading for parallel computation of marker effects\nIncludes automatic convergence retry on fitting failures\nMaximum fitting time per marker is limited to 60 seconds\n\nExamples\n\njulia> genomes = GenomicBreedingCore.simulategenomes(verbose=false);\n\njulia> ploidy = 4;\n\njulia> genomes.allele_frequencies = round.(genomes.allele_frequencies .* ploidy) ./ ploidy;\n\njulia> proportion_of_variance = zeros(9, 1); proportion_of_variance[1, 1] = 0.5;\n\njulia> trials, effects = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.05 0.00 0.00;], proportion_of_variance = proportion_of_variance, verbose=false);;\n\njulia> phenomes = extractphenomes(trials);\n\njulia> fit_1 = Suppressor.@suppress gwaslmm(genomes=genomes, phenomes=phenomes, GRM_type=\"simple\");\n\njulia> fit_1.model\n\"GWAS_LMM\"\n\njulia> fit_2 = Suppressor.@suppress gwaslmm(genomes=genomes, phenomes=phenomes, GRM_type=\"ploidy-aware\");\n\njulia> fit_2.model\n\"GWAS_LMM\"\n\njulia> findall(fit_1.b_hat .== maximum(fit_1.b_hat)) == findall(fit_2.b_hat .== maximum(fit_2.b_hat))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.gwasols-Tuple{}","page":"Home","title":"GenomicBreedingModels.gwasols","text":"gwasols(\n    genomes::Genomes,\n    phenomes::Phenomes;\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    idx_trait::Int64 = 1,\n    GRM_type::String = [\"simple\", \"ploidy-aware\"][1],\n    verbose::Bool = false,\n)::Fit\n\nPerform genome-wide association study (GWAS) using ordinary least squares (OLS) regression with population structure correction.\n\nArguments\n\ngenomes::Genomes: Genomic data structure containing allele frequencies\nphenomes::Phenomes: Phenotypic data structure containing trait measurements\nidx_entries::Union{Nothing,Vector{Int64}}: Optional indices to subset entries (default: all entries)\nidx_loci_alleles::Union{Nothing,Vector{Int64}}: Optional indices to subset loci/alleles (default: all loci)\nidx_trait::Int64: Index of the trait to analyze (default: 1)\nGRM_type::String: Type of genetic relationship matrix to use (\"simple\" or \"ploidy-aware\") (default: \"simple\")\nverbose::Bool: Whether to display progress and plots (default: false)\n\nReturns\n\nFit: A structure containing GWAS results including:\nmodel: Model identifier (\"GWAS_OLS\")\nb_hat: Vector of effect size estimates/t-statistics for each marker\nAdditional model information\n\nDetails\n\nThe function implements GWAS using OLS regression while accounting for population structure through the first principal component of the genetic relationship matrix (GRM) as a covariate. Two types of GRM can be used: \"simple\" assumes diploid organisms, while \"ploidy-aware\" accounts for different ploidy levels.\n\nExamples\n\njulia> genomes = GenomicBreedingCore.simulategenomes(verbose=false);\n\njulia> ploidy = 4;\n\njulia> genomes.allele_frequencies = round.(genomes.allele_frequencies .* ploidy) ./ ploidy;\n\njulia> proportion_of_variance = zeros(9, 1); proportion_of_variance[1, 1] = 0.5;\n\njulia> trials, effects = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.05 0.00 0.00;], proportion_of_variance = proportion_of_variance, verbose=false);;\n\njulia> phenomes = extractphenomes(trials);\n\njulia> fit_1 = gwasols(genomes=genomes, phenomes=phenomes, GRM_type=\"simple\");\n\njulia> fit_1.model\n\"GWAS_OLS\"\n\njulia> fit_2 = gwasols(genomes=genomes, phenomes=phenomes, GRM_type=\"ploidy-aware\");\n\njulia> fit_2.model\n\"GWAS_OLS\"\n\njulia> findall(fit_1.b_hat .== maximum(fit_1.b_hat)) == findall(fit_2.b_hat .== maximum(fit_2.b_hat))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.gwasprep-Tuple{}","page":"Home","title":"GenomicBreedingModels.gwasprep","text":"gwasprep(\n    genomes::Genomes,\n    phenomes::Phenomes;\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    idx_trait::Int64 = 1,\n    GRM_type::String = [\"simple\", \"ploidy-aware\"][1],\n    standardise::Bool = true,\n    verbose::Bool = false,\n)::Tuple{Matrix{Float64},Vector{Float64},Matrix{Float64},Fit}\n\nPrepare data matrices and structures for genome-wide association studies (GWAS).\n\nArguments\n\ngenomes::Genomes: Genomic data structure containing allele frequencies\nphenomes::Phenomes: Phenotypic data structure containing trait measurements\nidx_entries::Union{Nothing,Vector{Int64}}: Optional indices to subset entries (default: all entries)\nidx_loci_alleles::Union{Nothing,Vector{Int64}}: Optional indices to subset loci/alleles (default: all loci)\nidx_trait::Int64: Index of the trait to analyze (default: 1)\nGRM_type::String: Type of genetic relationship matrix to use (\"simple\" or \"ploidy-aware\") (default: \"simple\")\nstandardise::Bool: Whether to standardize the data matrices (default: true)\nverbose::Bool: Whether to print progress information (default: false)\n\nReturns\n\nA tuple containing:\n\nG::Matrix{Float64}: Standardized allele frequency matrix\ny::Vector{Float64}: Standardized phenotype vector  \nGRM::Matrix{Float64}: Genetic relationship matrix\nfit::Fit: Initialized Fit struct for GWAS results\n\nDetails\n\nPerforms data validation and preprocessing for GWAS analysis\nRemoves fixed loci with no variation\nStandardizes genomic and phenotypic data if requested\nConstructs appropriate genetic relationship matrix\nInitializes output structure for association results\n\nExamples\n\njulia> genomes = GenomicBreedingCore.simulategenomes(verbose=false);\n\njulia> ploidy = 4;\n\njulia> genomes.allele_frequencies = round.(genomes.allele_frequencies .* ploidy) ./ ploidy;\n\njulia> proportion_of_variance = zeros(9, 1); proportion_of_variance[1, 1] = 0.5;\n\njulia> trials, effects = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.05 0.00 0.00;], proportion_of_variance = proportion_of_variance, verbose=false);;\n\njulia> phenomes = extractphenomes(trials);\n\njulia> G, y, GRM, fit = gwasprep(genomes=genomes, phenomes=phenomes);\n\njulia> sum(abs.(mean(G, dims=1)[1,:]) .< 1e-10) == size(G, 2)\ntrue\n\njulia> sum(abs.(std(G, dims=1)[1,:] .- 1) .< 1e-10) == size(G, 2)\ntrue\n\njulia> (abs(mean(y)) < 1e-10, abs(std(y) - 1) < 1e-10)\n(true, true)\n\njulia> size(G, 1) == length(y)\ntrue\n\njulia> (size(G, 1), length(y)) == size(GRM)\ntrue\n\njulia> length(fit.entries) == length(y)\ntrue\n\njulia> length(fit.b_hat) == size(G, 2)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.gwasreml-Tuple{}","page":"Home","title":"GenomicBreedingModels.gwasreml","text":"gwasreml(\n    genomes::Genomes,\n    phenomes::Phenomes;\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    idx_trait::Int64 = 1,\n    GRM_type::String = \"simple\",\n    verbose::Bool = false\n)::Fit\n\nPerforms genome-wide association analysis using restricted maximum likelihood estimation (REML).\n\nArguments\n\ngenomes::Genomes: Genomic data structure containing allele frequencies\nphenomes::Phenomes: Phenotypic data structure containing trait measurements\nidx_entries::Union{Nothing,Vector{Int64}}: Optional indices to subset entries (default: nothing)\nidx_loci_alleles::Union{Nothing,Vector{Int64}}: Optional indices to subset loci/alleles (default: nothing)\nidx_trait::Int64: Index of the trait to analyze (default: 1)\nGRM_type::String: Type of genetic relationship matrix to use, either \"simple\" or \"ploidy-aware\" (default: \"simple\")\nverbose::Bool: Whether to display progress and plots (default: false)\n\nReturns\n\n::Fit: A Fit struct containing GWAS results, including effect estimates and test statistics\n\nDetails\n\nImplements the REML log-likelihood calculation for a mixed model of the form: y = Xβ + Zu + e where:\n\nβ are fixed effects\nu are random genetic effects with u ~ N(0, σ²_u * GRM)\ne are residual effects with e ~ N(0, σ²_e * I)\n\nThe function constructs the variance-covariance matrices and computes the REML transformation to obtain the log-likelihood value used in variance component estimation.\n\nExamples\n\njulia> genomes = GenomicBreedingCore.simulategenomes(l=1_000, verbose=false);\n\njulia> ploidy = 4;\n\njulia> genomes.allele_frequencies = round.(genomes.allele_frequencies .* ploidy) ./ ploidy;\n\njulia> proportion_of_variance = zeros(9, 1); proportion_of_variance[1, 1] = 0.5;\n\njulia> trials, effects = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.05 0.00 0.00;], proportion_of_variance = proportion_of_variance, verbose=false);;\n\njulia> phenomes = extractphenomes(trials);\n\njulia> fit_1 = gwasreml(genomes=genomes, phenomes=phenomes, GRM_type=\"simple\");\n\njulia> fit_1.model\n\"GWAS_REML\"\n\njulia> fit_2 = gwasreml(genomes=genomes, phenomes=phenomes, GRM_type=\"ploidy-aware\");\n\njulia> fit_2.model\n\"GWAS_REML\"\n\njulia> findall(fit_1.b_hat .== maximum(fit_1.b_hat)) == findall(fit_2.b_hat .== maximum(fit_2.b_hat))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.heritabilitynarrow_sense-Tuple{Vector{Float64}, Vector{Float64}}","page":"Home","title":"GenomicBreedingModels.heritabilitynarrow_sense","text":"heritabilitynarrow_sense(y_true::Vector{Float64}, y_pred::Vector{Float64})::Float64\n\nCalculate narrow-sense heritability (h²) from true and predicted phenotypic values.\n\nNarrow-sense heritability is the proportion of phenotypic variance that can be attributed to additive genetic effects. It is calculated as the ratio of additive genetic variance (s²a) to total phenotypic variance (s²a + s²e).\n\nArguments\n\ny_true::Vector{Float64}: Vector of observed/true phenotypic values\ny_pred::Vector{Float64}: Vector of predicted genetic values\n\nReturns\n\nFloat64: Narrow-sense heritability (h²) value between 0 and 1\n\nDetails\n\nReturns 0.0 if variance of either input vector is near zero (< 1e-10)\nAdditive genetic variance (s²a) is estimated from variance of predictions\nEnvironmental variance (s²e) is estimated from variance of residuals\nResult is bounded between 0 and 1\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.invoneplus-Tuple{Any}","page":"Home","title":"GenomicBreedingModels.invoneplus","text":"invoneplus(x) = 1 / (1 + x)\n\nThis function takes a number, adds one and inverts it. A member of the set of endofunctions defined in GenomicBreedingModels.jl for building non-linear genomic prediction models. Both input and ouput range between zero and one.\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.lasso-Tuple{}","page":"Home","title":"GenomicBreedingModels.lasso","text":"lasso(;\n    genomes::Genomes,\n    phenomes::Phenomes,\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    idx_trait::Int64 = 1,\n    verbose::Bool = false,\n)::Fit\n\nFits a LASSO (Least Absolute Shrinkage and Selection Operator) regression model with L1 regularization  for genomic prediction.\n\nArguments\n\ngenomes::Genomes: Genomic data structure containing allele frequencies\nphenomes::Phenomes: Phenotypic data structure containing trait measurements\nidx_entries::Union{Nothing,Vector{Int64}}: Optional indices to select specific entries/individuals\nidx_loci_alleles::Union{Nothing,Vector{Int64}}: Optional indices to select specific loci-alleles\nidx_trait::Int64: Index of the trait to analyze (default: 1)\nverbose::Bool: If true, prints diagnostic plots and additional information (default: false)\n\nReturns\n\nFit: A fitted model object containing:\nmodel: Model identifier (\"ols\")\nb_hat: Estimated regression coefficients\nb_hat_labels: Labels for the coefficients\ntrait: Name of the analyzed trait\nentries: Entry identifiers\npopulations: Population identifiers\ny_true: Observed phenotypic values\ny_pred: Predicted phenotypic values\nmetrics: Dictionary of performance metrics\n\nDetails\n\nThe function implements LASSO regression using the GLMNet package, which performs automatic  feature selection through L1 regularization. The optimal regularization parameter (λ) is  selected using cross-validation to minimize prediction error while promoting sparsity in  the coefficients.\n\nNotes\n\nStandardisation is disabled by default because the allele frequencies across loci are comparable as they all range from zero to one\nThe model includes an intercept term\n\nExamples\n\njulia> genomes = GenomicBreedingCore.simulategenomes(verbose=false);\n\njulia> trials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;\n\njulia> phenomes = extractphenomes(trials);\n\njulia> fit = lasso(genomes=genomes, phenomes=phenomes);\n\njulia> fit.model == \"lasso\"\ntrue\n\njulia> fit.metrics[\"cor\"] > 0.50\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.log10epsdivlog10eps-Tuple{Any}","page":"Home","title":"GenomicBreedingModels.log10epsdivlog10eps","text":"log10epsdivlog10eps(x) = (log10(abs(x) + eps(Float64))) / log10(eps(Float64))\n\nThis function takes a number, adds a very tiny value, takes the log10, and divide it by the log10 of the same very tiny value. A member of the set of endofunctions defined in GenomicBreedingModels.jl for building non-linear genomic prediction models. Both input and ouput range between zero and one.\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.loglikreml-Tuple{Vector{Float64}, Tuple{Vector{Float64}, Matrix{Float64}, Matrix{Float64}}}","page":"Home","title":"GenomicBreedingModels.loglikreml","text":"loglikreml(θ::Vector{Float64}, data::Tuple{Vector{Float64},Matrix{Float64},Matrix{Float64}})::Float64\n\nCalculate the restricted maximum likelihood (REML) log-likelihood for a mixed linear model.\n\nArguments\n\nθ::Vector{Float64}: Vector of variance components [σ²e, σ²u] where:\nσ²_e is the residual variance\nσ²_u is the genetic variance\ndata::Tuple{Vector{Float64},Matrix{Float64},Matrix{Float64}}: Tuple containing:\ny: Vector of phenotypic observations\nX: Design matrix for fixed effects\nGRM: Genomic relationship matrix\n\nReturns\n\nFloat64: The REML log-likelihood value. Returns Inf if matrix operations fail.\n\nDetails\n\nImplements the REML log-likelihood calculation for a mixed model of the form: y = Xβ + Zu + e where:\n\nβ are fixed effects\nu are random genetic effects with u ~ N(0, σ²_u * GRM)\ne are residual effects with e ~ N(0, σ²_e * I)\n\nThe function constructs the variance-covariance matrices and computes the REML transformation to obtain the log-likelihood value used in variance component estimation.\n\nExamples\n\n```jldoctest; setup = :(using GenomicBreedingCore, GenomicBreedingModels, LinearAlgebra, StatsBase) julia> genomes = GenomicBreedingCore.simulategenomes(verbose=false);\n\njulia> ploidy = 4;\n\njulia> genomes.allelefrequencies = round.(genomes.allelefrequencies .* ploidy) ./ ploidy;\n\njulia> proportionofvariance = zeros(9, 1); proportionofvariance[1, 1] = 0.5;\n\njulia> trials, effects = GenomicBreedingCore.simulatetrials(genomes=genomes, nyears=1, nseasons=1, nharvests=1, nsites=1, nreplications=1, fadddomepi=[0.05 0.00 0.00;], proportionofvariance = proportionofvariance, verbose=false);;\n\njulia> phenomes = extractphenomes(trials);\n\njulia> G, y, GRM, fit = gwasprep(genomes=genomes, phenomes=phenomes);\n\njulia> loglik = loglikreml([0.53, 0.15], (y, hcat(ones(length(y)), G[:, 1]), GRM));\n\njulia> loglik < 100 true\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.metrics-Tuple{Vector{Float64}, Vector{Float64}}","page":"Home","title":"GenomicBreedingModels.metrics","text":"metrics(y_true::Vector{Float64}, y_pred::Vector{Float64})::Dict{String,Float64}\n\nCalculate various metrics comparing predicted vs true values.\n\nReturns a dictionary containing the following metrics:\n\ncor: Pearson correlation coefficient\nmad: Mean absolute deviation\nmsd: Mean squared deviation\nrmsd: Root mean squared deviation  \nnrmsd: Normalized root mean squared deviation\neuc: Euclidean distance\njac: Jaccard distance\ntvar: Total variation distance\nh²: Narrow-sense heritability\n\nArguments\n\ny_true::Vector{Float64}: Vector of true/observed values\ny_pred::Vector{Float64}: Vector of predicted values\n\nReturns\n\nDict{String,Float64}: Dictionary mapping metric names to their calculated values\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.mlp-Tuple{}","page":"Home","title":"GenomicBreedingModels.mlp","text":"mlp(;\n    genomes::Genomes,\n    phenomes::Phenomes,\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    idx_trait::Int64 = 1,\n    n_layers::Int64 = 3,\n    activation::Function = relu,\n    max_n_nodes::Int64 = 256,\n    n_nodes_droprate::Float64 = 0.50,\n    dropout_droprate::Float64 = 0.25,\n    n_epochs::Int64 = 100_000,\n    use_cpu::Bool = false,\n    seed::Int64 = 123,\n    verbose::Bool = false\n)::Fit\n\nTrain a multi-layer perceptron (MLP) model for genomic prediction.\n\nArguments\n\ngenomes::Genomes: A Genomes struct containing the genomic data.\nphenomes::Phenomes: A Phenomes struct containing the phenomic data.\nidx_entries::Union{Nothing, Vector{Int64}}: Indices of entries to include in the model. If nothing, all entries are included. Default is nothing.\nidx_loci_alleles::Union{Nothing, Vector{Int64}}: Indices of loci-alleles to include in the model. If nothing, all loci-alleles are included. Default is nothing.\nidx_trait::Int64: Index of the trait to predict. Default is 1.\nn_layers::Int64: Number of layers in the MLP. Default is 3.\nactivation::Function: Activation function to use in the MLP. Default is relu.\nmax_n_nodes::Int64: Maximum number of nodes in each layer. Default is 256.\nn_nodes_droprate::Float64: Drop rate for the number of nodes in each layer. Default is 0.50.\ndropout_droprate::Float64: Dropout rate for the layers. Default is 0.25.\nn_epochs::Int64: Number of training epochs. Default is 100,000.\nuse_cpu::Bool: If true, use CPU for training. If false, use GPU if available. Default is false.\nseed::Int64: Random seed for reproducibility. Default is 123.\nverbose::Bool: If true, prints detailed progress information during training. Default is false.\n\nReturns\n\nFit: A Fit struct containing the trained MLP model and performance metrics.\n\nDetails\n\nThis function trains a multi-layer perceptron (MLP) model on genomic and phenomic data. The function performs the following steps:\n\nSet Random Seed: Sets the random seed for reproducibility.\nExtract Features and Targets: Extracts the feature matrix X, target vector y, and other relevant information from the genomic and phenomic data.\nInstantiate Output Fit: Creates a Fit struct to store the model and results.\nConstruct MLP Layers: Constructs the MLP layers based on the specified number of layers, activation function, and dropout rates.\nMove Data to Device: Moves the data to the appropriate device (CPU or GPU).\nSetup Training State: Initializes the training state with the model parameters and optimizer.\nTrain the Model: Trains the MLP model for the specified number of epochs, printing progress if verbose is true.\nEvaluate Performance: Evaluates the model's performance using the specified metrics.\nOutput: Returns the Fit struct containing the trained model and performance metrics.\n\nNotes\n\nThe function uses the Lux library for constructing and training the MLP model.\nThe verbose option provides additional insights into the training process by printing progress information.\nThe function ensures that the trained model and performance metrics are stored in the Fit struct.\n\nThrows\n\nArgumentError: If the Genomes or Phenomes struct is corrupted or if any of the arguments are out of range.\nErrorException: If an error occurs during model training or evaluation.\n\nExample\n\njulia> genomes = GenomicBreedingCore.simulategenomes(l=1_000, verbose=false);\n\njulia> trials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);\n\njulia> phenomes = extractphenomes(trials);\n\njulia> fit_cpu = Suppressor.@suppress mlp(genomes=genomes, phenomes=phenomes, n_epochs=1_000, use_cpu=true, verbose=false);\n\njulia> fit_gpu = Suppressor.@suppress mlp(genomes=genomes, phenomes=phenomes, n_epochs=1_000, use_cpu=false, verbose=false);\n\njulia> fit_cpu.metrics[\"cor\"] >= 0.2\ntrue\n\njulia> fit_gpu.metrics[\"cor\"] >= 0.2\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.mult-Tuple{Any, Any}","page":"Home","title":"GenomicBreedingModels.mult","text":"mult(x, y) = x * y\n\nThis function takes two numbers and multiplies them together. A member of the set of endofunctions defined in GenomicBreedingModels.jl for building non-linear genomic prediction models. Inputs and ouput range between zero and one.\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.ols-Tuple{}","page":"Home","title":"GenomicBreedingModels.ols","text":"ols(;\n    genomes::Genomes,\n    phenomes::Phenomes,\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    idx_trait::Int64 = 1,\n    verbose::Bool = false\n)::Fit\n\nFits an ordinary least squares (OLS) regression model to genomic and phenotypic data.\n\nArguments\n\ngenomes::Genomes: Genomic data structure containing allele frequencies\nphenomes::Phenomes: Phenotypic data structure containing trait measurements\nidx_entries::Union{Nothing,Vector{Int64}}: Optional indices to select specific entries (default: all entries)\nidx_loci_alleles::Union{Nothing,Vector{Int64}}: Optional indices to select specific loci-alleles (default: all loci-alleles)\nidx_trait::Int64: Index of the trait to analyze (default: 1)\nverbose::Bool: If true, displays diagnostic plots and performance metrics (default: false)\n\nReturns\n\nFit: A fitted model object containing:\nmodel: Model identifier (\"ols\")\nb_hat: Estimated regression coefficients\nb_hat_labels: Labels for the coefficients\ntrait: Name of the analyzed trait\nentries: Entry identifiers\npopulations: Population identifiers\ny_true: Observed phenotypic values\ny_pred: Predicted phenotypic values\nmetrics: Dictionary of performance metrics\n\nDescription\n\nPerforms ordinary least squares regression on genomic data to predict phenotypic values. The model includes an intercept term and estimates effects for each locus-allele combination.\n\nExamples\n\njulia> genomes = GenomicBreedingCore.simulategenomes(verbose=false);\n\njulia> trials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;\n\njulia> phenomes = extractphenomes(trials);\n\njulia> fit = ols(genomes=genomes, phenomes=phenomes);\n\njulia> fit.model == \"ols\"\ntrue\n\njulia> fit.metrics[\"cor\"] > 0.50\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.pearsonscorrelation-Tuple{Vector{Float64}, Vector{Float64}}","page":"Home","title":"GenomicBreedingModels.pearsonscorrelation","text":"pearsonscorrelation(y_true::Vector{Float64}, y_pred::Vector{Float64})::Float64\n\nCalculate the Pearson correlation coefficient between two vectors.\n\nThe Pearson correlation coefficient measures the linear correlation between two variables, giving a value between -1 and +1, where:\n\n+1 represents perfect positive correlation\n0 represents no linear correlation\n-1 represents perfect negative correlation\n\nArguments\n\ny_true::Vector{Float64}: Vector of true/actual values\ny_pred::Vector{Float64}: Vector of predicted/estimated values\n\nReturns\n\nFloat64: Pearson correlation coefficient\n\nNotes\n\nReturns 0.0 if the variance of either input vector is less than 1e-10\nUses 1 - correlation distance from Distances.jl package\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.predict-Tuple{}","page":"Home","title":"GenomicBreedingModels.predict","text":"predict(; fit::Fit, genomes::Genomes, idx_entries::Vector{Int64})::Vector{Float64}\n\nCalculate predicted phenotypes using a fitted genomic prediction model.\n\nArguments\n\nfit::Fit: A fitted genomic prediction model containing coefficients and model information\ngenomes::Genomes: Genomic data containing allele frequencies\nidx_entries::Vector{Int64}: Vector of indices specifying which entries to predict\n\nReturns\n\nVector{Float64}: Predicted phenotypic values for the specified entries\n\nDetails\n\nSupports various linear genomic prediction models including:\n\nOLS (Ordinary Least Squares)\nRidge Regression\nLASSO\nBayes A\nBayes B\nBayes C\n\nThe function validates input dimensions and compatibility between the fitted model and genomic data before making predictions.\n\nThrows\n\nArgumentError: If the Fit or Genomes structs are corrupted\nArgumentError: If entry indices are out of bounds\nArgumentError: If loci-alleles in the fitted model don't match the validation set\nArgumentError: If the genomic prediction model is not recognized\n\nExamples\n\njulia> genomes = GenomicBreedingCore.simulategenomes(verbose=false);\n\njulia> trials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);\n\njulia> phenomes = extractphenomes(trials);\n\njulia> fit = ridge(genomes=genomes, phenomes=phenomes, idx_entries=collect(1:90));\n\njulia> y_hat = GenomicBreedingModels.predict(fit=fit, genomes=genomes, idx_entries=collect(91:100));\n\njulia> cor(phenomes.phenotypes[91:100, 1], y_hat) > 0.5\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.raise-Tuple{Any, Any}","page":"Home","title":"GenomicBreedingModels.raise","text":"raise(x, y) = x^y\n\nThis function raises the first value to the power of the second value. A member of the set of endofunctions defined in GenomicBreedingModels.jl for building non-linear genomic prediction models. Inputs and ouput range between zero and one.\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.reconstitutefeatures-Tuple{GenomicBreedingCore.Genomes}","page":"Home","title":"GenomicBreedingModels.reconstitutefeatures","text":"reconstitutefeatures(\n    genomes::Genomes;\n    feature_names::Vector{String},\n    verbose::Bool = false\n)::Genomes\n\nReconstruct epistasis features from a Genomes struct using feature names that encode the transformations applied.\n\nArguments\n\ngenomes::Genomes: Genomic data structure containing allele frequencies\nfeature_names::Vector{String}: Vector of feature names containing encoded transformation information\nverbose::Bool: Whether to show progress bar during reconstruction (default: false)\n\nReturns\n\nGenomes: A new Genomes struct with reconstructed epistasis features\n\nDetails\n\nThe function parses the feature names to determine which transformations were applied and reconstructs the features by applying these transformations to the original genomic data. Feature names should  contain the transformation operations in a format that can be parsed and evaluated.\n\nThrows\n\nArgumentError: If the input Genomes struct is corrupted (invalid dimensions)\nErrorException: If feature reconstruction fails\n\nExample\n\njulia> genomes = GenomicBreedingCore.simulategenomes(l=1_000, verbose=false);\n\njulia> trials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;\n\njulia> phenomes = extractphenomes(trials);\n\njulia> genomes_epifeat = epistasisfeatures(genomes, phenomes, n_new_features_per_transformation=50, n_reps=2, verbose=false);\n\njulia> feature_names = genomes_epifeat.loci_alleles;\n\njulia> genomes_epifeat_reconstructed = reconstitutefeatures(genomes, feature_names=feature_names);\n\njulia> genomes_epifeat == genomes_epifeat_reconstructed\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.ridge-Tuple{}","page":"Home","title":"GenomicBreedingModels.ridge","text":"ridge(;\n    genomes::Genomes,\n    phenomes::Phenomes,\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    idx_trait::Int64 = 1,\n    verbose::Bool = false\n)::Fit\n\nFit a ridge (L2) regression model to genomic data. Ridge regression adds an L2 regularization term  to the ordinary least squares objective function, which helps prevent overfitting and handles  multicollinearity in the predictors.\n\nArguments\n\ngenomes::Genomes: Genomic data structure containing allele frequencies\nphenomes::Phenomes: Phenotypic data structure containing trait measurements\nidx_entries::Union{Nothing,Vector{Int64}}: Optional indices to subset specific entries/individuals\nidx_loci_alleles::Union{Nothing,Vector{Int64}}: Optional indices to subset specific loci-alleles\nidx_trait::Int64: Index of the trait to analyze (default: 1)\nverbose::Bool: If true, prints diagnostic plots and additional information (default: false)\n\nReturns\n\nFit: A fitted model object containing:\nmodel: Model identifier (\"ols\")\nb_hat: Estimated regression coefficients\nb_hat_labels: Labels for the coefficients\ntrait: Name of the analyzed trait\nentries: Entry identifiers\npopulations: Population identifiers\ny_true: Observed phenotypic values\ny_pred: Predicted phenotypic values\nmetrics: Dictionary of performance metrics\n\nNotes\n\nUses cross-validation to select the optimal regularization parameter (λ)\nStandardizes predictors before fitting\nIncludes an intercept term in the model\n\nExamples\n\njulia> genomes = GenomicBreedingCore.simulategenomes(verbose=false);\n\njulia> trials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;\n\njulia> phenomes = extractphenomes(trials);\n\njulia> fit = ridge(genomes=genomes, phenomes=phenomes);\n\njulia> fit.model == \"ridge\"\ntrue\n\njulia> fit.metrics[\"cor\"] > 0.50\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.square-Tuple{Any}","page":"Home","title":"GenomicBreedingModels.square","text":"square(x) = x^2\n\nThis function takes a number and squares it. A member of the set of endofunctions defined in GenomicBreedingModels.jl for building non-linear genomic prediction models. Both input and ouput range between zero and one.\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.transform1-Tuple{Function, GenomicBreedingCore.Genomes, GenomicBreedingCore.Phenomes}","page":"Home","title":"GenomicBreedingModels.transform1","text":"transform1(\n    f::Function,\n    genomes::Genomes,\n    phenomes::Phenomes;\n    idx_trait::Int64 = 1,\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    n_new_features_per_transformation::Int64 = 1_000,\n    ϵ::Float64 = eps(Float64),\n    use_abs::Bool = false,\n    σ²_threshold::Float64 = 0.01,\n    verbose::Bool = false\n)::Genomes\n\nApply a transformation function to each allele frequency in genomic data while considering their effects on phenotypes.\n\nArguments\n\nf::Function: Transformation function to apply to allele frequencies\ngenomes::Genomes: Input genomic data structure\nphenomes::Phenomes: Corresponding phenotypic data structure\n\nKeywords\n\nidx_trait::Int64: Index of the trait to analyze (default: 1)\nidx_entries::Union{Nothing,Vector{Int64}}: Indices of entries to include (default: all)\nidx_loci_alleles::Union{Nothing,Vector{Int64}}: Indices of loci-alleles to include (default: all)\nn_new_features_per_transformation::Int64: Maximum number of transformed features to retain (default: 1000)\nϵ::Float64: Small value added to prevent numerical issues (default: machine epsilon)\nuse_abs::Bool: Whether to use absolute values before transformation (default: false)\nσ²_threshold::Float64: Minimum variance threshold for considering a locus (default: 0.01)\nverbose::Bool: Whether to show progress and plots (default: false)\n\nReturns\n\nGenomes: A new Genomes object containing the transformed allele frequencies\n\nDetails\n\nThe function performs the following steps:\n\nExtracts allele frequencies and phenotypic data\nApplies the transformation function to each locus\nEstimates effects using ordinary least squares\nSelects the most important transformed features\nCleans numerical artifacts (values near 0 or 1)\n\nNotes\n\nUse named functions to ensure transformations can be reconstructed from loci_alleles\nThe function adds ϵ to frequencies to prevent numerical issues\nFeatures with variance below σ²_threshold are skipped\nThe output contains at most n_new_features_per_transformation features\n\nExample\n\njulia> genomes = GenomicBreedingCore.simulategenomes(l=1_000, verbose=false);\n\njulia> trials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;\n\njulia> phenomes = extractphenomes(trials);\n\njulia> genomes_transformed = transform1(x -> x^2, genomes, phenomes);\n\njulia> idx = findall(genomes.loci_alleles .== split(split(replace(genomes_transformed.loci_alleles[1], \")\" => \"\"), \"(\")[2], \",\")[1])[1];\n\njulia> mean(sqrt.(genomes_transformed.allele_frequencies[:, 1]) .- genomes.allele_frequencies[:, idx]) < 1e-10\ntrue\n\njulia> squareaddpi(x) = x^2 + pi;\n\njulia> genomes_transformed = transform1(squareaddpi, genomes, phenomes);\n\njulia> idx = findall(genomes.loci_alleles .== split(split(replace(genomes_transformed.loci_alleles[1], \")\" => \"\"), \"(\")[2], \",\")[1])[1];\n\njulia> mean(squareaddpi.(genomes.allele_frequencies[:, idx]) .- genomes_transformed.allele_frequencies[:, 1]) < 1e-10\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.transform2-Tuple{Function, GenomicBreedingCore.Genomes, GenomicBreedingCore.Phenomes}","page":"Home","title":"GenomicBreedingModels.transform2","text":"transform2(\n    f::Function,\n    genomes::Genomes,\n    phenomes::Phenomes;\n    idx_trait::Int64 = 1,\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    n_new_features_per_transformation::Int64 = 1_000,\n    ϵ::Float64 = eps(Float64),\n    use_abs::Bool = false,\n    σ²_threshold::Float64 = 0.01,\n    commutative::Bool = false,\n    verbose::Bool = false\n)::Genomes\n\nApply a transformation function to pairs of allele frequencies in genomic data while considering their effects on phenotypes.\n\nArguments\n\nf::Function: Transformation function to apply to pairs of allele frequencies\ngenomes::Genomes: Input genomic data structure\nphenomes::Phenomes: Corresponding phenotypic data structure\nidx_trait::Int64: Index of the trait to analyze (default: 1)\nidx_entries::Union{Nothing,Vector{Int64}}: Subset of entries to include (default: all)\nidx_loci_alleles::Union{Nothing,Vector{Int64}}: Subset of loci-alleles to include (default: all)\nn_new_features_per_transformation::Int64: Maximum number of transformed features to retain (default: 1000)\nϵ::Float64: Small value added to frequencies to avoid numerical issues (default: machine epsilon)\nuse_abs::Bool: Whether to use absolute values of frequencies (default: false)\nσ²_threshold::Float64: Minimum variance threshold for considering loci (default: 0.01)\ncommutative::Bool: Whether the transformation function is commutative (default: false)\nverbose::Bool: Whether to display progress and diagnostics (default: false)\n\nReturns\n\nGenomes: A new Genomes object containing the transformed features\n\nDetails\n\nThe function performs the following steps:\n\nExtracts allele frequencies and phenotypic data\nApplies the transformation function to all possible pairs of allele freuqencies (i.e., locus-allele combinations)\nEstimates effects using ordinary least squares\nSelects the most important transformed features\nCleans numerical artifacts (values near 0 or 1)\n\nNotes\n\nUse named functions to ensure transformations can be reconstructed from loci_alleles\nThe function adds ϵ to frequencies to prevent numerical issues\nFeatures with variance below σ²_threshold are skipped\nThe output contains at most n_new_features_per_transformation features\n\nExamples\n\njulia> genomes = GenomicBreedingCore.simulategenomes(l=1_000, verbose=false);\n\njulia> trials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;\n\njulia> phenomes = extractphenomes(trials);\n\njulia> genomes_transformed = transform2((x,y) -> (x^2 + sqrt(y)) / 2, genomes, phenomes);\n\njulia> idx_1 = findall(genomes.loci_alleles .== split(split(replace(genomes_transformed.loci_alleles[1], \")\" => \"\"), \"(\")[2], \",\")[1])[1];\n\njulia> idx_2 = findall(genomes.loci_alleles .== split(split(replace(genomes_transformed.loci_alleles[1], \")\" => \"\"), \"(\")[2], \",\")[2])[1];\n\njulia> mean((genomes.allele_frequencies[:,idx_1].^2 .+ sqrt.(genomes.allele_frequencies[:,idx_2])) ./ 2 .- genomes_transformed.allele_frequencies[:,1]) < 1e-10\ntrue\n\njulia> raisexbyythenlog(x, y) = log(abs(x^y));\n\njulia> genomes_transformed = transform2(raisexbyythenlog, genomes, phenomes);\n\njulia> idx_1 = findall(genomes.loci_alleles .== split(split(replace(genomes_transformed.loci_alleles[1], \")\" => \"\"), \"(\")[2], \",\")[1])[1];\n\njulia> idx_2 = findall(genomes.loci_alleles .== split(split(replace(genomes_transformed.loci_alleles[1], \")\" => \"\"), \"(\")[2], \",\")[2])[1];\n\njulia> mean(raisexbyythenlog.(genomes.allele_frequencies[:,idx_1], genomes.allele_frequencies[:,idx_2]) .- genomes_transformed.allele_frequencies[:,1]) < 1e-10\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.turing_bayesG-Tuple{Any, Any}","page":"Home","title":"GenomicBreedingModels.turing_bayesG","text":"Turing specification of Bayesian linear regression using a Gaussian prior with common variance\n\nExample usage\n\n# Benchmarking\ngenomes = GenomicBreedingCore.simulategenomes(n=10, l=100)\ntrials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])\nphenomes = extractphenomes(trials)\nG::Matrix{Float64} = genomes.allele_frequencies\ny::Vector{Float64} = phenomes.phenotypes[:, 1]\nmodel = turing_bayesG(G, y)\nbenchmarks = TuringBenchmarking.benchmark_model(\n    model;\n    # Check correctness of computations\n    check=true,\n    # Automatic differentiation backends to check and benchmark\n    adbackends=[:forwarddiff, :reversediff, :reversediff_compiled, :zygote]\n)\n\n# Test more loci\ngenomes = GenomicBreedingCore.simulategenomes(n=10, l=10_000)\ntrials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])\nphenomes = extractphenomes(trials)\nG::Matrix{Float64} = genomes.allele_frequencies\ny::Vector{Float64} = phenomes.phenotypes[:, 1]\n# Check for uninferred types in the model\n@code_warntype model = turing_bayesG(G, y)\n# Fit\nmodel = turing_bayesG(G, y)\n# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below\nrng::TaskLocalRNG = Random.seed!(123)\nniter::Int64 = 1_500\nnburnin::Int64 = 500\n@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.65, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);\n# @time chain = Turing.sample(rng, model, HMC(0.05, 10; adtype=AutoReverseDiff(compile=true)), niter, progress=true);\np = Plots.histogram(chain[:σ²])\nPlots.gui(p)\n# Use the mean paramter values after 150 burn-in iterations\nparams = Turing.get_params(chain[501:end, :, :]);\nb_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);\n# Assess prediction accuracy\ny_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;\nUnicodePlots.scatterplot(y, y_pred)\nperformance::Dict{String, Float64} = metrics(y, y_pred)\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.turing_bayesG_logit-Tuple{Any, Any}","page":"Home","title":"GenomicBreedingModels.turing_bayesG_logit","text":"Turing specification of Bayesian logistic regression using a Gaussian prior with common variance\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.turing_bayesGs-Tuple{Any, Any}","page":"Home","title":"GenomicBreedingModels.turing_bayesGs","text":"Turing specification of Bayesian linear regression using a Gaussian prior with varying variances\n\nExample usage\n\n# Simulate data\ngenomes = GenomicBreedingCore.simulategenomes(n=10, l=100)\ntrials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])\nphenomes = extractphenomes(trials)\n# Extract genotype and phenotype data\nG::Matrix{Float64} = genomes.allele_frequencies\ny::Vector{Float64} = phenomes.phenotypes[:, 1]\n# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.\nmodel = turing_bayesGs(G, y)\n# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below\nrng::TaskLocalRNG = Random.seed!(123)\nniter::Int64 = 1_500\nnburnin::Int64 = 500\n@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);\n# Use the mean paramter values after 150 burn-in iterations\nparams = Turing.get_params(chain[150:end, :, :]);\nb_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);\n# Assess prediction accuracy\ny_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;\nUnicodePlots.scatterplot(y, y_pred)\nperformance::Dict{String, Float64} = metrics(y, y_pred)\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.turing_bayesGπ-Tuple{Any, Any}","page":"Home","title":"GenomicBreedingModels.turing_bayesGπ","text":"Turing specification of Bayesian linear regression using a Gaussian prior with a point mass at zero and common variance\n\nExample usage\n\n# Simulate data\ngenomes = GenomicBreedingCore.simulategenomes(n=10, l=100)\ntrials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])\nphenomes = extractphenomes(trials)\n# Extract genotype and phenotype data\nG::Matrix{Float64} = genomes.allele_frequencies\ny::Vector{Float64} = phenomes.phenotypes[:, 1]\n# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.\nmodel = turing_bayesGπ(G, y)\n# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below\nrng::TaskLocalRNG = Random.seed!(123)\nniter::Int64 = 1_500\nnburnin::Int64 = 500\n@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);\n# Use the mean paramter values after 150 burn-in iterations\nparams = Turing.get_params(chain[150:end, :, :]);\nb_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);\n# Assess prediction accuracy\ny_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;\nUnicodePlots.scatterplot(y, y_pred)\nperformance::Dict{String, Float64} = metrics(y, y_pred)\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.turing_bayesGπs-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, DynamicPPL.TypeWrap{T}}} where T","page":"Home","title":"GenomicBreedingModels.turing_bayesGπs","text":"Turing specification of Bayesian linear regression using a Gaussian prior with a point mass at zero and varying variances\n\nExample usage\n\n# Simulate data\ngenomes = GenomicBreedingCore.simulategenomes(n=10, l=100)\ntrials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])\nphenomes = extractphenomes(trials)\n# Extract genotype and phenotype data\nG::Matrix{Float64} = genomes.allele_frequencies\ny::Vector{Float64} = phenomes.phenotypes[:, 1]\n# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.\nmodel = turing_bayesGπs(G, y)\n# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below\nrng::TaskLocalRNG = Random.seed!(123)\nniter::Int64 = 1_500\nnburnin::Int64 = 500\n@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);\n# Use the mean paramter values after 150 burn-in iterations\nparams = Turing.get_params(chain[150:end, :, :]);\nb_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);\n# Assess prediction accuracy\ny_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;\nUnicodePlots.scatterplot(y, y_pred)\nperformance::Dict{String, Float64} = metrics(y, y_pred)\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.turing_bayesL-Tuple{Any, Any}","page":"Home","title":"GenomicBreedingModels.turing_bayesL","text":"Turing specification of Bayesian linear regression using a Laplacian prior with a common scale\n\nExample usage\n\n# Simulate data\ngenomes = GenomicBreedingCore.simulategenomes(n=10, l=100)\ntrials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])\nphenomes = extractphenomes(trials)\n# Extract genotype and phenotype data\nG::Matrix{Float64} = genomes.allele_frequencies\ny::Vector{Float64} = phenomes.phenotypes[:, 1]\n# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.\nmodel = turing_bayesL(G, y)\n# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below\nrng::TaskLocalRNG = Random.seed!(123)\nniter::Int64 = 1_500\nnburnin::Int64 = 500\n@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);\n# Use the mean paramter values after 150 burn-in iterations\nparams = Turing.get_params(chain[150:end, :, :]);\nb_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);\n# Assess prediction accuracy\ny_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;\nUnicodePlots.scatterplot(y, y_pred)\nperformance::Dict{String, Float64} = metrics(y, y_pred)\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.turing_bayesLs-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, DynamicPPL.TypeWrap{T}}} where T","page":"Home","title":"GenomicBreedingModels.turing_bayesLs","text":"Turing specification of Bayesian linear regression using a Laplacian prior with varying scales\n\nExample usage\n\n# Simulate data\ngenomes = GenomicBreedingCore.simulategenomes(n=10, l=100)\ntrials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])\nphenomes = extractphenomes(trials)\n# Extract genotype and phenotype data\nG::Matrix{Float64} = genomes.allele_frequencies\ny::Vector{Float64} = phenomes.phenotypes[:, 1]\n# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.\nmodel = turing_bayesLs(G, y)\n# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below\nrng::TaskLocalRNG = Random.seed!(123)\nniter::Int64 = 1_500\nnburnin::Int64 = 500\n@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);\n# Use the mean paramter values after 150 burn-in iterations\nparams = Turing.get_params(chain[150:end, :, :]);\nb_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);\n# Assess prediction accuracy\ny_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;\nUnicodePlots.scatterplot(y, y_pred)\nperformance::Dict{String, Float64} = metrics(y, y_pred)\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.turing_bayesLπ-Tuple{Any, Any}","page":"Home","title":"GenomicBreedingModels.turing_bayesLπ","text":"Turing specification of Bayesian linear regression using a Laplacian prior with a point mass at zero and common scale\n\nExample usage\n\n# Simulate data\ngenomes = GenomicBreedingCore.simulategenomes(n=10, l=100)\ntrials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])\nphenomes = extractphenomes(trials)\n# Extract genotype and phenotype data\nG::Matrix{Float64} = genomes.allele_frequencies\ny::Vector{Float64} = phenomes.phenotypes[:, 1]\n# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.\nmodel = turing_bayesLπ(G, y)\n# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below\nrng::TaskLocalRNG = Random.seed!(123)\nniter::Int64 = 1_500\nnburnin::Int64 = 500\n@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);\n# Use the mean paramter values after 150 burn-in iterations\nparams = Turing.get_params(chain[150:end, :, :]);\nb_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);\n# Assess prediction accuracy\ny_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;\nUnicodePlots.scatterplot(y, y_pred)\nperformance::Dict{String, Float64} = metrics(y, y_pred)\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.turing_bayesLπs-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, DynamicPPL.TypeWrap{T}}} where T","page":"Home","title":"GenomicBreedingModels.turing_bayesLπs","text":"Turing specification of Bayesian linear regression using a Laplacian prior with a point mass at zero and common scale\n\nExample usage\n\n# Simulate data\ngenomes = GenomicBreedingCore.simulategenomes(n=10, l=100)\ntrials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])\nphenomes = extractphenomes(trials)\n# Extract genotype and phenotype data\nG::Matrix{Float64} = genomes.allele_frequencies\ny::Vector{Float64} = phenomes.phenotypes[:, 1]\n# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.\nmodel = turing_bayesLπs(G, y)\n# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below\nrng::TaskLocalRNG = Random.seed!(123)\nniter::Int64 = 1_500\nnburnin::Int64 = 500\n@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);\n# Use the mean paramter values after 150 burn-in iterations\nparams = Turing.get_params(chain[150:end, :, :]);\nb_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);\n# Assess prediction accuracy\ny_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;\nUnicodePlots.scatterplot(y, y_pred)\nperformance::Dict{String, Float64} = metrics(y, y_pred)\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.turing_bayesT-Tuple{Any, Any}","page":"Home","title":"GenomicBreedingModels.turing_bayesT","text":"Turing specification of Bayesian linear regression using a T-distribution\n\nExample usage\n\n# Simulate data\ngenomes = GenomicBreedingCore.simulategenomes(n=10, l=100)\ntrials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])\nphenomes = extractphenomes(trials)\n# Extract genotype and phenotype data\nG::Matrix{Float64} = genomes.allele_frequencies\ny::Vector{Float64} = phenomes.phenotypes[:, 1]\n# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.\nmodel = turing_bayesT(G, y)\n# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below\nrng::TaskLocalRNG = Random.seed!(123)\nniter::Int64 = 1_500\nnburnin::Int64 = 500\n@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);\n# Use the mean paramter values after 150 burn-in iterations\nparams = Turing.get_params(chain[150:end, :, :]);\nb_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);\n# Assess prediction accuracy\ny_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;\nUnicodePlots.scatterplot(y, y_pred)\nperformance::Dict{String, Float64} = metrics(y, y_pred)\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.turing_bayesTπ-Tuple{Any, Any}","page":"Home","title":"GenomicBreedingModels.turing_bayesTπ","text":"Turing specification of Bayesian linear regression using a T-distribution with a point mass at zero\n\nExample usage\n\n# Simulate data\ngenomes = GenomicBreedingCore.simulategenomes(n=10, l=100)\ntrials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])\nphenomes = extractphenomes(trials)\n# Extract genotype and phenotype data\nG::Matrix{Float64} = genomes.allele_frequencies\ny::Vector{Float64} = phenomes.phenotypes[:, 1]\n# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.\nmodel = turing_bayesTπ(G, y)\n# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below\nrng::TaskLocalRNG = Random.seed!(123)\nniter::Int64 = 1_500\nnburnin::Int64 = 500\n@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);\n# Use the mean paramter values after 150 burn-in iterations\nparams = Turing.get_params(chain[150:end, :, :]);\nb_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);\n# Assess prediction accuracy\ny_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;\nUnicodePlots.scatterplot(y, y_pred)\nperformance::Dict{String, Float64} = metrics(y, y_pred)\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.validate-Tuple{GenomicBreedingCore.Fit, GenomicBreedingCore.Genomes, GenomicBreedingCore.Phenomes}","page":"Home","title":"GenomicBreedingModels.validate","text":"validate(\n    fit::Fit,\n    genomes::Genomes,\n    phenomes::Phenomes;\n    idx_validation::Vector{Int64},\n    replication::String=\"\",\n    fold::String=\"\"\n)::CV\n\nEvaluate the predictive accuracy of a genomic prediction model on a validation dataset.\n\nArguments\n\nfit::Fit: A fitted genomic prediction model\ngenomes::Genomes: Genomic data structure containing allele frequencies\nphenomes::Phenomes: Phenotypic data structure containing trait measurements\nidx_validation::Vector{Int64}: Indices of entries to use for validation\nreplication::String: Optional identifier for the validation replication\nfold::String: Optional identifier for the cross-validation fold\n\nReturns\n\nCV: A cross-validation result object containing:\nValidation metrics (correlation, RMSE, etc.)\nTrue and predicted values\nEntry and population information\nModel specifications\n\nNotes\n\nPerforms checks for data leakage between training and validation sets\nHandles missing, NaN, and Inf values in phenotypic data\nValidates dimensions of output CV struct\n\nExamples\n\njulia> genomes = GenomicBreedingCore.simulategenomes(verbose=false);\n\njulia> trials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);\n\njulia> phenomes = extractphenomes(trials);\n\njulia> fit = ridge(genomes=genomes, phenomes=phenomes, idx_entries=collect(1:90));\n\njulia> cv = validate(fit, genomes, phenomes, idx_validation=collect(91:100));\n\njulia> cv.metrics[\"cor\"] > 0.50\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingModels.@string2operations-Tuple{Any}","page":"Home","title":"GenomicBreedingModels.@string2operations","text":"@string2operations(x)\n\nConvert a string containing an endofunction formulae for genomic features into a parsed Julia expressions.\n\nArguments\n\nx: A string containing mathematical operations on allele frequencies\n\nReturns\n\nParsed expression that can be evaluated in Julia\n\n\n\n\n\n","category":"macro"}]
}
