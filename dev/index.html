<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · GBModels.jl</title><meta name="title" content="Home · GBModels.jl"/><meta property="og:title" content="Home · GBModels.jl"/><meta property="twitter:title" content="Home · GBModels.jl"/><meta name="description" content="Documentation for GBModels.jl."/><meta property="og:description" content="Documentation for GBModels.jl."/><meta property="twitter:description" content="Documentation for GBModels.jl."/><meta property="og:url" content="https://GenomicBreeding.github.io/GBModels.jl/"/><meta property="twitter:url" content="https://GenomicBreeding.github.io/GBModels.jl/"/><link rel="canonical" href="https://GenomicBreeding.github.io/GBModels.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>GBModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GenomicBreeding/GBModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GenomicBreeding/GBModels.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="GBModels"><a class="docs-heading-anchor" href="#GBModels">GBModels</a><a id="GBModels-1"></a><a class="docs-heading-anchor-permalink" href="#GBModels" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/GenomicBreeding/GBModels.jl">GBModels</a>.</p><ul><li><a href="#GBModels.LπDist"><code>GBModels.LπDist</code></a></li><li><a href="#GBModels.NπDist"><code>GBModels.NπDist</code></a></li><li><a href="#GBModels.TπDist"><code>GBModels.TπDist</code></a></li><li><a href="#Base.maximum-Tuple{GBModels.TπDist}"><code>Base.maximum</code></a></li><li><a href="#Base.maximum-Tuple{GBModels.NπDist}"><code>Base.maximum</code></a></li><li><a href="#Base.maximum-Tuple{GBModels.LπDist}"><code>Base.maximum</code></a></li><li><a href="#Base.minimum-Tuple{GBModels.TπDist}"><code>Base.minimum</code></a></li><li><a href="#Base.minimum-Tuple{GBModels.NπDist}"><code>Base.minimum</code></a></li><li><a href="#Base.minimum-Tuple{GBModels.LπDist}"><code>Base.minimum</code></a></li><li><a href="#Base.rand-Tuple{Random.AbstractRNG, GBModels.LπDist}"><code>Base.rand</code></a></li><li><a href="#Base.rand-Tuple{Random.AbstractRNG, GBModels.NπDist}"><code>Base.rand</code></a></li><li><a href="#Base.rand-Tuple{Random.AbstractRNG, GBModels.TπDist}"><code>Base.rand</code></a></li><li><a href="#Distributions.logpdf-Tuple{GBModels.LπDist, Real}"><code>Distributions.logpdf</code></a></li><li><a href="#Distributions.logpdf-Tuple{GBModels.NπDist, Real}"><code>Distributions.logpdf</code></a></li><li><a href="#Distributions.logpdf-Tuple{GBModels.TπDist, Real}"><code>Distributions.logpdf</code></a></li><li><a href="#GBModels.addnorm-Tuple{Any, Any}"><code>GBModels.addnorm</code></a></li><li><a href="#GBModels.bayesa-Tuple{}"><code>GBModels.bayesa</code></a></li><li><a href="#GBModels.bayesb-Tuple{}"><code>GBModels.bayesb</code></a></li><li><a href="#GBModels.bayesc-Tuple{}"><code>GBModels.bayesc</code></a></li><li><a href="#GBModels.bayesian-Tuple{Function}"><code>GBModels.bayesian</code></a></li><li><a href="#GBModels.bayesian-Tuple{String}"><code>GBModels.bayesian</code></a></li><li><a href="#GBModels.bglr-Tuple{}"><code>GBModels.bglr</code></a></li><li><a href="#GBModels.cvbulk-Tuple{}"><code>GBModels.cvbulk</code></a></li><li><a href="#GBModels.cvleaveonepopulationout-Tuple{}"><code>GBModels.cvleaveonepopulationout</code></a></li><li><a href="#GBModels.cvmultithread!-Tuple{Vector{GBCore.CV}}"><code>GBModels.cvmultithread!</code></a></li><li><a href="#GBModels.cvpairwisepopulation-Tuple{}"><code>GBModels.cvpairwisepopulation</code></a></li><li><a href="#GBModels.cvperpopulation-Tuple{}"><code>GBModels.cvperpopulation</code></a></li><li><a href="#GBModels.epistasisfeatures-Tuple{GBCore.Genomes, GBCore.Phenomes}"><code>GBModels.epistasisfeatures</code></a></li><li><a href="#GBModels.extractxyetc-Tuple{GBCore.Genomes, GBCore.Phenomes}"><code>GBModels.extractxyetc</code></a></li><li><a href="#GBModels.grmploidyaware-Tuple{GBCore.Genomes}"><code>GBModels.grmploidyaware</code></a></li><li><a href="#GBModels.grmsimple-Tuple{GBCore.Genomes}"><code>GBModels.grmsimple</code></a></li><li><a href="#GBModels.gwaslmm-Tuple{}"><code>GBModels.gwaslmm</code></a></li><li><a href="#GBModels.gwasols-Tuple{}"><code>GBModels.gwasols</code></a></li><li><a href="#GBModels.gwasprep-Tuple{}"><code>GBModels.gwasprep</code></a></li><li><a href="#GBModels.gwasreml-Tuple{}"><code>GBModels.gwasreml</code></a></li><li><a href="#GBModels.heritabilitynarrow_sense-Tuple{Vector{Float64}, Vector{Float64}}"><code>GBModels.heritabilitynarrow_sense</code></a></li><li><a href="#GBModels.invoneplus-Tuple{Any}"><code>GBModels.invoneplus</code></a></li><li><a href="#GBModels.lasso-Tuple{}"><code>GBModels.lasso</code></a></li><li><a href="#GBModels.log10epsdivlog10eps-Tuple{Any}"><code>GBModels.log10epsdivlog10eps</code></a></li><li><a href="#GBModels.loglikreml-Tuple{Vector{Float64}, Tuple{Vector{Float64}, Matrix{Float64}, Matrix{Float64}}}"><code>GBModels.loglikreml</code></a></li><li><a href="#GBModels.metrics-Tuple{Vector{Float64}, Vector{Float64}}"><code>GBModels.metrics</code></a></li><li><a href="#GBModels.mlp-Tuple{}"><code>GBModels.mlp</code></a></li><li><a href="#GBModels.mult-Tuple{Any, Any}"><code>GBModels.mult</code></a></li><li><a href="#GBModels.ols-Tuple{}"><code>GBModels.ols</code></a></li><li><a href="#GBModels.pearsonscorrelation-Tuple{Vector{Float64}, Vector{Float64}}"><code>GBModels.pearsonscorrelation</code></a></li><li><a href="#GBModels.predict-Tuple{}"><code>GBModels.predict</code></a></li><li><a href="#GBModels.raise-Tuple{Any, Any}"><code>GBModels.raise</code></a></li><li><a href="#GBModels.reconstitutefeatures-Tuple{GBCore.Genomes}"><code>GBModels.reconstitutefeatures</code></a></li><li><a href="#GBModels.ridge-Tuple{}"><code>GBModels.ridge</code></a></li><li><a href="#GBModels.square-Tuple{Any}"><code>GBModels.square</code></a></li><li><a href="#GBModels.transform1-Tuple{Function, GBCore.Genomes, GBCore.Phenomes}"><code>GBModels.transform1</code></a></li><li><a href="#GBModels.transform2-Tuple{Function, GBCore.Genomes, GBCore.Phenomes}"><code>GBModels.transform2</code></a></li><li><a href="#GBModels.turing_bayesG-Tuple{Any, Any}"><code>GBModels.turing_bayesG</code></a></li><li><a href="#GBModels.turing_bayesG_logit-Tuple{Any, Any}"><code>GBModels.turing_bayesG_logit</code></a></li><li><a href="#GBModels.turing_bayesGs-Tuple{Any, Any}"><code>GBModels.turing_bayesGs</code></a></li><li><a href="#GBModels.turing_bayesGπ-Tuple{Any, Any}"><code>GBModels.turing_bayesGπ</code></a></li><li><a href="#GBModels.turing_bayesGπs-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, DynamicPPL.TypeWrap{T}}} where T"><code>GBModels.turing_bayesGπs</code></a></li><li><a href="#GBModels.turing_bayesL-Tuple{Any, Any}"><code>GBModels.turing_bayesL</code></a></li><li><a href="#GBModels.turing_bayesLs-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, DynamicPPL.TypeWrap{T}}} where T"><code>GBModels.turing_bayesLs</code></a></li><li><a href="#GBModels.turing_bayesLπ-Tuple{Any, Any}"><code>GBModels.turing_bayesLπ</code></a></li><li><a href="#GBModels.turing_bayesLπs-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, DynamicPPL.TypeWrap{T}}} where T"><code>GBModels.turing_bayesLπs</code></a></li><li><a href="#GBModels.turing_bayesT-Tuple{Any, Any}"><code>GBModels.turing_bayesT</code></a></li><li><a href="#GBModels.turing_bayesTπ-Tuple{Any, Any}"><code>GBModels.turing_bayesTπ</code></a></li><li><a href="#GBModels.validate-Tuple{GBCore.Fit, GBCore.Genomes, GBCore.Phenomes}"><code>GBModels.validate</code></a></li><li><a href="#GBModels.@string2operations-Tuple{Any}"><code>GBModels.@string2operations</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.LπDist" href="#GBModels.LπDist"><code>GBModels.LπDist</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Laplace distribution with a point mass at 0.0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/bayes.jl#L569-L571">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.NπDist" href="#GBModels.NπDist"><code>GBModels.NπDist</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Gaussian distribution with a point mass at 0.0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/bayes.jl#L336-L338">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.TπDist" href="#GBModels.TπDist"><code>GBModels.TπDist</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>T-distribution with a point mass at 0.0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/bayes.jl#L758-L760">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.maximum-Tuple{GBModels.LπDist}" href="#Base.maximum-Tuple{GBModels.LπDist}"><code>Base.maximum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Maximum value of the LπDist distribution</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/bayes.jl#L621-L623">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.maximum-Tuple{GBModels.NπDist}" href="#Base.maximum-Tuple{GBModels.NπDist}"><code>Base.maximum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Maximum value of the NπDist distribution</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/bayes.jl#L388-L390">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.maximum-Tuple{GBModels.TπDist}" href="#Base.maximum-Tuple{GBModels.TπDist}"><code>Base.maximum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Maximum value of the TπDist distribution</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/bayes.jl#L809-L811">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.minimum-Tuple{GBModels.LπDist}" href="#Base.minimum-Tuple{GBModels.LπDist}"><code>Base.minimum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Minimum value of the LπDist distribution</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/bayes.jl#L616-L618">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.minimum-Tuple{GBModels.NπDist}" href="#Base.minimum-Tuple{GBModels.NπDist}"><code>Base.minimum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Minimum value of the NπDist distribution</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/bayes.jl#L383-L385">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.minimum-Tuple{GBModels.TπDist}" href="#Base.minimum-Tuple{GBModels.TπDist}"><code>Base.minimum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Minimum value of the TπDist distribution</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/bayes.jl#L804-L806">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rand-Tuple{Random.AbstractRNG, GBModels.LπDist}" href="#Base.rand-Tuple{Random.AbstractRNG, GBModels.LπDist}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Sampling method for LπDist</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">d = LπDist(0.1, 0.0, 1.0)
rand(d)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/bayes.jl#L578-L586">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rand-Tuple{Random.AbstractRNG, GBModels.NπDist}" href="#Base.rand-Tuple{Random.AbstractRNG, GBModels.NπDist}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Sampling method for NπDist</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">d = NπDist(0.1, 0.0, 1.0)
rand(d)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/bayes.jl#L345-L353">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rand-Tuple{Random.AbstractRNG, GBModels.TπDist}" href="#Base.rand-Tuple{Random.AbstractRNG, GBModels.TπDist}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Sampling method for TπDist</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">d = TπDist(0.1, 1.0)
rand(d)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/bayes.jl#L766-L774">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Distributions.logpdf-Tuple{GBModels.LπDist, Real}" href="#Distributions.logpdf-Tuple{GBModels.LπDist, Real}"><code>Distributions.logpdf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>log(pdf) of LπDist</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">d = LπDist(0.1, 0.0, 1.0)
logpdf.(d, [-1.0, 0.0, 1.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/bayes.jl#L597-L605">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Distributions.logpdf-Tuple{GBModels.NπDist, Real}" href="#Distributions.logpdf-Tuple{GBModels.NπDist, Real}"><code>Distributions.logpdf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>log(pdf) of NπDist</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">d = NπDist(0.1, 0.0, 1.0)
logpdf.(d, [-1.0, 0.0, 1.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/bayes.jl#L364-L372">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Distributions.logpdf-Tuple{GBModels.TπDist, Real}" href="#Distributions.logpdf-Tuple{GBModels.TπDist, Real}"><code>Distributions.logpdf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>log(pdf) of TπDist</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">d = TπDist(0.1, 1.0)
logpdf.(d, [-1.0, 0.0, 1.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/bayes.jl#L785-L793">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.addnorm-Tuple{Any, Any}" href="#GBModels.addnorm-Tuple{Any, Any}"><code>GBModels.addnorm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addnorm(x, y) = (x + y) / 2.0</code></pre><p>This function takes two numbers and finds their arithmetic mean. A member of the set of endofunctions defined in GBModels.jl for building non-linear genomic prediction models. Inputs and ouput range between zero and one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/transformation.jl#L38-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.bayesa-Tuple{}" href="#GBModels.bayesa-Tuple{}"><code>GBModels.bayesa</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bayesa(;
    genomes::Genomes,
    phenomes::Phenomes,
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    idx_trait::Int64 = 1,
    n_iter::Int64 = 1_500,
    n_burnin::Int64 = 500,
    verbose::Bool = false
)::Fit</code></pre><p>Fits a Bayes A model for genomic prediction using the BGLR method. Bayes A assumes marker effects follow a scaled-t distribution, allowing for different variances for each marker effect.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: Genomic data structure containing allele frequencies</li><li><code>phenomes::Phenomes</code>: Phenotypic data structure containing trait measurements</li><li><code>idx_entries::Union{Nothing,Vector{Int64}}</code>: Optional indices to subset specific entries/individuals</li><li><code>idx_loci_alleles::Union{Nothing,Vector{Int64}}</code>: Optional indices to subset specific genetic markers</li><li><code>idx_trait::Int64</code>: Index of the trait to analyze (default: 1)</li><li><code>n_iter::Int64</code>: Number of iterations for the MCMC algorithm (default: 1,500)</li><li><code>n_burnin::Int64</code>: Number of burn-in iterations to discard (default: 500)</li><li><code>verbose::Bool</code>: Whether to print progress messages (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>Fit</code>: A fitted model object containing:<ul><li><code>model</code>: Model identifier (&quot;ols&quot;)</li><li><code>b_hat</code>: Estimated regression coefficients</li><li><code>b_hat_labels</code>: Labels for the coefficients</li><li><code>trait</code>: Name of the analyzed trait</li><li><code>entries</code>: Entry identifiers</li><li><code>populations</code>: Population identifiers</li><li><code>y_true</code>: Observed phenotypic values</li><li><code>y_pred</code>: Predicted phenotypic values</li><li><code>metrics</code>: Dictionary of performance metrics</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>The model assumes a Gaussian distribution for the trait values</li><li>Recommended to check convergence by examining trace plots of key parameters</li><li>The burn-in period should be adjusted based on convergence diagnostics</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;

julia&gt; phenomes = extractphenomes(trials);

julia&gt; fit = bayesa(genomes=genomes, phenomes=phenomes);

julia&gt; fit.model == &quot;bayesa&quot;
true

julia&gt; fit.metrics[&quot;cor&quot;] &gt; 0.50
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/linear.jl#L381-L439">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.bayesb-Tuple{}" href="#GBModels.bayesb-Tuple{}"><code>GBModels.bayesb</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bayesb(;
    genomes::Genomes,
    phenomes::Phenomes,
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    idx_trait::Int64 = 1,
    n_iter::Int64 = 1_500,
    n_burnin::Int64 = 500,
    verbose::Bool = false
)::Fit</code></pre><p>Fits a Bayes B model for genomic prediction using the BGLR method. Bayes B assumes that marker effects follow a mixture distribution where some markers have zero effect and others follow a scaled-t distribution.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: Genomic data structure containing allele frequencies</li><li><code>phenomes::Phenomes</code>: Phenotypic data structure containing trait measurements</li><li><code>idx_entries::Union{Nothing,Vector{Int64}}</code>: Optional indices to subset specific entries (default: nothing)</li><li><code>idx_loci_alleles::Union{Nothing,Vector{Int64}}</code>: Optional indices to subset specific loci/alleles (default: nothing)</li><li><code>idx_trait::Int64</code>: Index of the trait to analyze (default: 1)</li><li><code>n_iter::Int64</code>: Number of iterations for the MCMC algorithm (default: 1,500)</li><li><code>n_burnin::Int64</code>: Number of burn-in iterations to discard (default: 500)</li><li><code>verbose::Bool</code>: Whether to print progress information (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>Fit</code>: A fitted model object containing:<ul><li><code>model</code>: Model identifier (&quot;ols&quot;)</li><li><code>b_hat</code>: Estimated regression coefficients</li><li><code>b_hat_labels</code>: Labels for the coefficients</li><li><code>trait</code>: Name of the analyzed trait</li><li><code>entries</code>: Entry identifiers</li><li><code>populations</code>: Population identifiers</li><li><code>y_true</code>: Observed phenotypic values</li><li><code>y_pred</code>: Predicted phenotypic values</li><li><code>metrics</code>: Dictionary of performance metrics</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;

julia&gt; phenomes = extractphenomes(trials);

julia&gt; fit = bayesb(genomes=genomes, phenomes=phenomes);

julia&gt; fit.model == &quot;bayesb&quot;
true

julia&gt; fit.metrics[&quot;cor&quot;] &gt; 0.50
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/linear.jl#L467-L520">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.bayesc-Tuple{}" href="#GBModels.bayesc-Tuple{}"><code>GBModels.bayesc</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bayesc(;
    genomes::Genomes,
    phenomes::Phenomes,
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    idx_trait::Int64 = 1,
    n_iter::Int64 = 1_500,
    n_burnin::Int64 = 500,
    verbose::Bool = false
)::Fit</code></pre><p>Fits a Bayes C model for genomic prediction using the BGLR method. Bayes C assumes that marker effects follow  a mixture distribution with a point mass at zero and a normal distribution.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: Genomic data structure containing allele frequencies</li><li><code>phenomes::Phenomes</code>: Phenotypic data structure containing trait measurements</li><li><code>idx_entries::Union{Nothing,Vector{Int64}}</code>: Optional indices to subset specific entries/individuals</li><li><code>idx_loci_alleles::Union{Nothing,Vector{Int64}}</code>: Optional indices to subset specific loci/alleles</li><li><code>idx_trait::Int64</code>: Index of the trait to analyze (default: 1)</li><li><code>n_iter::Int64</code>: Number of iterations for MCMC sampling (default: 1,500)</li><li><code>n_burnin::Int64</code>: Number of burn-in iterations to discard (default: 500)</li><li><code>verbose::Bool</code>: Whether to print progress information (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>Fit</code>: A fitted model object containing:<ul><li><code>model</code>: Model identifier (&quot;ols&quot;)</li><li><code>b_hat</code>: Estimated regression coefficients</li><li><code>b_hat_labels</code>: Labels for the coefficients</li><li><code>trait</code>: Name of the analyzed trait</li><li><code>entries</code>: Entry identifiers</li><li><code>populations</code>: Population identifiers</li><li><code>y_true</code>: Observed phenotypic values</li><li><code>y_pred</code>: Predicted phenotypic values</li><li><code>metrics</code>: Dictionary of performance metrics</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;

julia&gt; phenomes = extractphenomes(trials);

julia&gt; fit = bayesc(genomes=genomes, phenomes=phenomes);

julia&gt; fit.model == &quot;bayesc&quot;
true

julia&gt; fit.metrics[&quot;cor&quot;] &gt; 0.50
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/linear.jl#L548-L601">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.bayesian-Tuple{Function}" href="#GBModels.bayesian-Tuple{Function}"><code>GBModels.bayesian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bayesian(
    turing_model::Function;
    X::Matrix{Float64},
    y::Vector{Float64},
    sampler::String = [&quot;NUTS&quot;, &quot;HMC&quot;, &quot;HMCDA&quot;, &quot;MH&quot;, &quot;PG&quot;][1],
    sampling_method::Int64 = 1,
    seed::Int64 = 123,
    n_burnin::Int64 = 500,
    n_iter::Int64 = 1_500,
    verbose::Bool = false,
)::Fit</code></pre><p>Fit a Bayesian linear regression models via Turing.jl</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);

julia&gt; phenomes = extractphenomes(trials);

julia&gt; sol = Suppressor.@suppress bayesian(turing_bayesG, genomes=genomes, phenomes=phenomes);

julia&gt; # Slow because not multivariate T-dist: sol_T = Suppressor.@suppress bayesian(turing_bayesT, genomes=genomes, phenomes=phenomes);

julia&gt; # Even slower because of an extra set of distribution to define a non-spherical variance-covariance matrix: sol_Gs = Suppressor.@suppress bayesian(turing_bayesGs, genomes=genomes, phenomes=phenomes);

julia&gt; sol_BGLR = Suppressor.@suppress bayesian(&quot;BayesA&quot;, genomes=genomes, phenomes=phenomes); sol.metrics[&quot;cor&quot;] &gt; sol_BGLR.metrics[&quot;cor&quot;]
true

julia&gt; sol.metrics[&quot;cor&quot;] &gt; 0.5
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/bayes.jl#L874-L909">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.bayesian-Tuple{String}" href="#GBModels.bayesian-Tuple{String}"><code>GBModels.bayesian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bayesian(
    bglr_model::String;
    genomes::Genomes,
    phenomes::Phenomes,
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    idx_trait::Int64 = 1,
    response_type::String = [&quot;gaussian&quot;, &quot;ordinal&quot;][1], 
    n_burnin::Int64 = 500,
    n_iter::Int64 = 1_500, 
    verbose::Bool = false
)::Fit</code></pre><p>Fit Bayesian genomic prediction models using the BGLR R package.</p><p><strong>Arguments</strong></p><ul><li><code>bglr_model::String</code>: Type of BGLR model to fit. Options: &quot;BayesA&quot;, &quot;BayesB&quot;, &quot;BayesC&quot;</li><li><code>genomes::Genomes</code>: Genomic data structure containing allele frequencies</li><li><code>phenomes::Phenomes</code>: Phenotypic data structure containing trait measurements</li><li><code>idx_entries::Union{Nothing,Vector{Int64}}</code>: Optional indices to subset entries </li><li><code>idx_loci_alleles::Union{Nothing,Vector{Int64}}</code>: Optional indices to subset loci/alleles</li><li><code>idx_trait::Int64</code>: Index of trait to analyze (default: 1)</li><li><code>response_type::String</code>: Type of response variable. Options: &quot;gaussian&quot; or &quot;ordinal&quot; (default: &quot;gaussian&quot;)</li><li><code>n_burnin::Int64</code>: Number of burn-in MCMC iterations (default: 500)</li><li><code>n_iter::Int64</code>: Total number of MCMC iterations (default: 1,500)</li><li><code>verbose::Bool</code>: Whether to print progress information (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>Fit</code>: Object containing:<ul><li>Model fit summary</li><li>Estimated genetic effects</li><li>Predicted values  </li><li>Model performance metrics</li><li>Input data details</li></ul></li></ul><p><strong>Details</strong></p><p>This function provides a Julia interface to the BGLR R package for Bayesian genomic prediction. It uses temporary files to interface with R and automatically cleans up afterward.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);

julia&gt; phenomes = extractphenomes(trials);

julia&gt; sol = Suppressor.@suppress bayesian(&quot;BayesA&quot;, genomes=genomes, phenomes=phenomes);

julia&gt; sol.metrics[&quot;cor&quot;] &gt; 0.5
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/bayes.jl#L107-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.bglr-Tuple{}" href="#GBModels.bglr-Tuple{}"><code>GBModels.bglr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bglr(; G::Matrix{Float64}, y::Vector{Float64}, model::String=&quot;BayesA&quot;, 
     response_type::String=&quot;gaussian&quot;, n_iter::Int64=1_500, 
     n_burnin::Int64=500, verbose::Bool=false)::Vector{Float64}</code></pre><p>Perform Bayesian genomic prediction using the BGLR (Bayesian Generalized Linear Regression) R package.</p><p><strong>Arguments</strong></p><ul><li><code>G::Matrix{Float64}</code>: Marker matrix where rows represent individuals and columns represent locus-allele combinations</li><li><code>y::Vector{Float64}</code>: Vector of phenotypic values</li><li><code>model::String</code>: Bayesian model type to use. Options: &quot;BayesA&quot;, &quot;BayesB&quot;, or &quot;BayesC&quot;. Default: &quot;BayesA&quot;</li><li><code>response_type::String</code>: Type of response variable. Options: &quot;gaussian&quot; or &quot;ordinal&quot;. Default: &quot;gaussian&quot;</li><li><code>n_iter::Int64</code>: Number of iterations for the MCMC chain. Default: 1,500</li><li><code>n_burnin::Int64</code>: Number of burn-in iterations to discard. Default: 500</li><li><code>verbose::Bool</code>: Whether to print progress information. Default: false</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: Estimated effects including the intercept (first element) followed by marker effects</li></ul><p><strong>Details</strong></p><p>This function creates temporary files to interface with R&#39;s BGLR package, runs the Bayesian analysis, and automatically cleans up temporary files afterward. The function uses the system&#39;s R installation  and requires the BGLR package to be installed in R.</p><p><strong>Notes</strong></p><p>This is hacky. It invokes Rscript for each instance which should allow multithreading because RCall.jl currently does not allow multithreading.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/bayes.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.cvbulk-Tuple{}" href="#GBModels.cvbulk-Tuple{}"><code>GBModels.cvbulk</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cvbulk(;
    genomes::Genomes,
    phenomes::Phenomes,
    models::Vector{Function}=[ridge],
    n_replications::Int64=5,
    n_folds::Int64=5,
    seed::Int64=42,
    verbose::Bool=true
)::Tuple{Vector{CV}, Vector{String}}</code></pre><p>Perform replicated k-fold cross-validation of genomic prediction model(s) across all available traits and entries, ignoring populations.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: Genomic data structure containing allele frequencies</li><li><code>phenomes::Phenomes</code>: Phenotypic data structure containing trait measurements</li><li><code>models::Vector{Function}</code>: Vector of genomic prediction model functions to evaluate</li><li><code>n_replications::Int64</code>: Number of times to repeat k-fold cross-validation randomising k-fold partitioning each time (default: 5)</li><li><code>n_folds::Int64</code>: Number of cross-validation folds (default: 5) </li><li><code>seed::Int64</code>: Random seed for reproducibility (default: 42)</li><li><code>verbose::Bool</code>: Whether to display progress information (default: true)</li></ul><p><strong>Returns</strong></p><ul><li>Tuple containing:<ul><li>Vector of CV objects with cross-validation results</li><li>Vector of warning messages about skipped cases</li></ul></li></ul><p><strong>Threading</strong></p><p>Uses multiple threads if Julia is started with threading enabled. Example startup command: <code>julia --threads 7,1</code> (7 worker threads, 1 runtime thread)</p><p><strong>Notes</strong></p><ul><li>Performs random k-fold partitioning of entries ignoring population structure</li><li>Handles missing/invalid phenotype values</li><li>Validates model inputs and data dimensions</li><li>Returns warnings for cases with insufficient data or zero variance</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false); genomes.populations = StatsBase.sample(string.(&quot;pop_&quot;, 1:3), length(genomes.entries), replace=true);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, verbose=false);

julia&gt; phenomes = extractphenomes(trials);

julia&gt; cvs, notes = cvbulk(genomes=genomes, phenomes=phenomes, models=[ols, ridge], n_replications=2, n_folds=2, verbose=false);

julia&gt; df_across_entries, df_per_entry = tabularise(cvs);

julia&gt; idx_across = findall((df_across_entries.trait .== &quot;trait_1&quot;) .&amp;&amp; (df_across_entries.model .== &quot;ridge&quot;) .&amp;&amp; (df_across_entries.replication .== &quot;replication_1&quot;) .&amp;&amp; (df_across_entries.fold .== &quot;fold_1&quot;));

julia&gt; idx_per = findall((df_per_entry.trait .== &quot;trait_1&quot;) .&amp;&amp; (df_per_entry.model .== &quot;ridge&quot;) .&amp;&amp; (df_per_entry.replication .== &quot;replication_1&quot;) .&amp;&amp; (df_per_entry.fold .== &quot;fold_1&quot;));

julia&gt; abs(df_across_entries.cor[idx_across][1] - cor(df_per_entry.y_true[idx_per], df_per_entry.y_pred[idx_per])) &lt; 1e-10
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/cross_validation.jl#L208-L265">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.cvleaveonepopulationout-Tuple{}" href="#GBModels.cvleaveonepopulationout-Tuple{}"><code>GBModels.cvleaveonepopulationout</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cvleaveonepopulationout(;
    genomes::Genomes,
    phenomes::Phenomes,
    models::Vector{Function}=[ridge],
    n_replications::Int64=5,
    n_folds::Int64=5,
    seed::Int64=42,
    verbose::Bool=true
)::Tuple{Vector{CV}, Vector{String}}</code></pre><p>Performs leave-one-population-out cross-validation for genomic prediction models across all available traits.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: Genomic data structure containing allele frequencies</li><li><code>phenomes::Phenomes</code>: Phenotypic data structure containing trait measurements</li><li><code>models::Vector{Function}</code>: Vector of model functions to evaluate (default: [ridge])</li><li><code>n_replications::Int64</code>: Number of replications (not used in this implementation)</li><li><code>n_folds::Int64</code>: Number of folds (not used in this implementation)</li><li><code>seed::Int64</code>: Random seed (not used in this implementation)</li><li><code>verbose::Bool</code>: If true, displays progress information during execution</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Vector{CV}, Vector{String}}</code>: Returns a tuple containing:<ul><li>Vector of CV objects with cross-validation results</li><li>Vector of warning/error messages for skipped validations</li></ul></li></ul><p><strong>Details</strong></p><p>The function implements a leave-one-population-out cross-validation strategy where:</p><ol><li>For each trait and population combination:<ul><li>Uses one population as validation set</li><li>Uses remaining populations as training set</li></ul></li><li>Evaluates multiple genomic prediction models</li><li>Handles missing data and variance checks</li><li>Supports parallel processing via Julia&#39;s multi-threading</li></ol><p><strong>Threading</strong></p><p>To utilize multiple threads, start Julia with: <code>julia --threads n,1</code> where n is the desired number of threads for computation and 1 is reserved for the runtime.</p><p><strong>Supported Models</strong></p><ul><li>ols (Ordinary Least Squares)</li><li>ridge (Ridge Regression)</li><li>lasso (Lasso Regression)</li><li>bayesa (Bayes A)</li><li>bayesb (Bayes B)</li><li>bayesc (Bayes C)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false); genomes.populations = StatsBase.sample(string.(&quot;pop_&quot;, 1:3), length(genomes.entries), replace=true);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);

julia&gt; phenomes = extractphenomes(trials);

julia&gt; cvs, notes = cvleaveonepopulationout(genomes=genomes, phenomes=phenomes, models=[ridge, bayesa], n_replications=2, n_folds=2, verbose=false);

julia&gt; df_across_entries, df_per_entry = tabularise(cvs);

julia&gt; sum([sum(split(df_across_entries.training_population[i], &quot;;&quot;) .== df_across_entries.validation_population[i]) for i in 1:size(df_across_entries, 1)]) == 0
true

julia&gt; idx_across = findall((df_across_entries.validation_population .== &quot;pop_1&quot;) .&amp;&amp; (df_across_entries.trait .== &quot;trait_1&quot;) .&amp;&amp; (df_across_entries.model .== &quot;ridge&quot;));

julia&gt; idx_per = findall((df_per_entry.validation_population .== &quot;pop_1&quot;) .&amp;&amp; (df_per_entry.trait .== &quot;trait_1&quot;) .&amp;&amp; (df_per_entry.model .== &quot;ridge&quot;));

julia&gt; abs(df_across_entries.cor[idx_across][1] - cor(df_per_entry.y_true[idx_per], df_per_entry.y_pred[idx_per])) &lt; 1e-10
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/cross_validation.jl#L829-L899">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.cvmultithread!-Tuple{Vector{GBCore.CV}}" href="#GBModels.cvmultithread!-Tuple{Vector{GBCore.CV}}"><code>GBModels.cvmultithread!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cvmultithread!(cvs::Vector{CV}; genomes::Genomes, phenomes::Phenomes, models_vector, verbose::Bool = true)::Vector{CV}</code></pre><p>Perform multi-threaded genomic prediction cross-validation using specified models.</p><p><strong>Arguments</strong></p><ul><li><code>cvs::Vector{CV}</code>: Vector of cross-validation objects to be processed</li><li><code>genomes::Genomes</code>: Genomic data structure containing allele frequencies</li><li><code>phenomes::Phenomes</code>: Phenotypic data structure containing trait measurements</li><li><code>models_vector</code>: Vector of model functions to be used for prediction (e.g., [ridge, bayesa])</li><li><code>verbose::Bool=true</code>: Whether to display progress bar during computation</li></ul><p><strong>Returns</strong></p><ul><li>Modified <code>cvs</code> vector with updated cross-validation results</li></ul><p><strong>Threading</strong></p><p>Requires Julia to be started with multiple threads to utilize parallel processing. Example startup command: <code>julia --threads 7,1</code> (7 worker threads, 1 runtime thread)</p><p><strong>Details</strong></p><p>The function performs cross-validation in parallel for each CV object using the corresponding model from the models_vector. For each fold:</p><ol><li>Extracts training and validation indices</li><li>Fits the specified model using training data</li><li>Validates the model using validation data</li><li>Updates the CV object with prediction results</li></ol><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);

julia&gt; phenomes = extractphenomes(trials);

julia&gt; idx_training = collect(1:50);

julia&gt; idx_validation_1 = collect(51:75);

julia&gt; idx_validation_2 = collect(76:100);

julia&gt; fit = Fit(n = length(idx_training), l = length(genomes.loci_alleles) + 1); fit.model = &quot;ridge&quot;; fit.trait = &quot;trait_1&quot;; 

julia&gt; fit.entries = genomes.entries[idx_training]; fit.populations = genomes.populations[idx_training]; 

julia&gt; fit.b_hat_labels = vcat([&quot;intercept&quot;], genomes.loci_alleles);

julia&gt; cv_1 = CV(&quot;replication_1&quot;, &quot;fold_1&quot;, fit, genomes.populations[idx_validation_1], genomes.entries[idx_validation_1], zeros(length(idx_validation_1)), zeros(length(idx_validation_1)), fit.metrics);

julia&gt; cv_2 = CV(&quot;replication_1&quot;, &quot;fold_2&quot;, fit, genomes.populations[idx_validation_2], genomes.entries[idx_validation_2], zeros(length(idx_validation_2)), zeros(length(idx_validation_2)), fit.metrics);

julia&gt; cvs = [cv_1, cv_2]; models = [ridge, ridge];

julia&gt; cvmultithread!(cvs, genomes=genomes, phenomes=phenomes, models_vector=[ridge, bayesa], verbose=false);

julia&gt; df_across_entries, df_per_entry = tabularise(cvs);

julia&gt; idx_across = findall(df_across_entries.fold .== &quot;fold_2&quot;);

julia&gt; idx_per = findall(df_per_entry.fold .== &quot;fold_2&quot;);

julia&gt; abs(df_across_entries.cor[idx_across][1] - cor(df_per_entry.y_true[idx_per], df_per_entry.y_pred[idx_per])) &lt; 1e-10
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/cross_validation.jl#L85-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.cvpairwisepopulation-Tuple{}" href="#GBModels.cvpairwisepopulation-Tuple{}"><code>GBModels.cvpairwisepopulation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cvpairwisepopulation(;
    genomes::Genomes,
    phenomes::Phenomes,
    models::Vector{Function}=[ridge],
    n_replications::Int64=5,
    n_folds::Int64=5, 
    seed::Int64=42,
    verbose::Bool=true
)::Tuple{Vector{CV}, Vector{String}}</code></pre><p>Performs pairwise cross-validation between populations for genomic prediction models.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: Genomic data structure containing allele frequencies</li><li><code>phenomes::Phenomes</code>: Phenotypic data structure containing trait measurements</li><li><code>models::Vector{Function}</code>: Vector of genomic prediction model functions to evaluate (default: [ridge])</li><li><code>n_replications::Int64</code>: Number of replications (unused, maintained for API consistency)</li><li><code>n_folds::Int64</code>: Number of folds (unused, maintained for API consistency)  </li><li><code>seed::Int64</code>: Random seed (unused, maintained for API consistency)</li><li><code>verbose::Bool</code>: Whether to display progress information</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Vector{CV}, Vector{String}}</code>: <ul><li>Vector of CV objects containing cross-validation results</li><li>Vector of warning messages for skipped validations</li></ul></li></ul><p><strong>Details</strong></p><p>For each pair of populations (pop1, pop2):</p><ol><li>Uses pop1 as training set and pop2 as validation set</li><li>Skips within-population validation (pop1==pop2)</li><li>Evaluates each model on all available traits</li><li>Handles missing/invalid phenotype values</li><li>Validates model inputs and data dimensions</li></ol><p><strong>Threading</strong></p><p>Requires Julia to be started with multiple threads: <code>julia --threads n,1</code> where n is number of worker threads</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false); genomes.populations = StatsBase.sample(string.(&quot;pop_&quot;, 1:3), length(genomes.entries), replace=true);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);

julia&gt; phenomes = extractphenomes(trials);

julia&gt; cvs, notes = cvpairwisepopulation(genomes=genomes, phenomes=phenomes, models=[ols, ridge], n_replications=2, n_folds=2, verbose=false);

julia&gt; df_across_entries, df_per_entry = tabularise(cvs);

julia&gt; sum(df_across_entries.training_population .!= df_across_entries.validation_population) == size(df_across_entries, 1)
true

julia&gt; idx_across = findall((df_across_entries.training_population .== &quot;pop_1&quot;) .&amp;&amp; (df_across_entries.validation_population .== &quot;pop_2&quot;) .&amp;&amp; (df_across_entries.trait .== &quot;trait_1&quot;) .&amp;&amp; (df_across_entries.model .== &quot;ridge&quot;));

julia&gt; idx_per = findall((df_per_entry.training_population .== &quot;pop_1&quot;) .&amp;&amp; (df_per_entry.validation_population .== &quot;pop_2&quot;) .&amp;&amp; (df_per_entry.trait .== &quot;trait_1&quot;) .&amp;&amp; (df_per_entry.model .== &quot;ridge&quot;));

julia&gt; abs(df_across_entries.cor[idx_across][1] - cor(df_per_entry.y_true[idx_per], df_per_entry.y_pred[idx_per])) &lt; 1e-10
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/cross_validation.jl#L596-L657">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.cvperpopulation-Tuple{}" href="#GBModels.cvperpopulation-Tuple{}"><code>GBModels.cvperpopulation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cvperpopulation(;
    genomes::Genomes,
    phenomes::Phenomes,
    models::Vector{Function}=[ridge],
    n_replications::Int64=5,
    n_folds::Int64=5,
    seed::Int64=42,
    verbose::Bool=true
)::Tuple{Vector{CV}, Vector{String}}</code></pre><p>Performs within-population replicated cross-validation of genomic prediction models across all available traits.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: Genomic data structure containing allele frequencies</li><li><code>phenomes::Phenomes</code>: Phenotypic data structure containing trait measurements</li><li><code>models::Vector{Function}=[ridge]</code>: Vector of genomic prediction model functions to evaluate</li><li><code>n_replications::Int64=5</code>: Number of replications for cross-validation</li><li><code>n_folds::Int64=5</code>: Number of folds for k-fold cross-validation</li><li><code>seed::Int64=42</code>: Random seed for reproducibility</li><li><code>verbose::Bool=true</code>: Whether to print progress information</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Vector{CV}, Vector{String}}</code>: A tuple containing:<ul><li>Vector of CV objects with cross-validation results</li><li>Vector of notes/warnings generated during the process</li></ul></li></ul><p><strong>Details</strong></p><p>The function performs separate cross-validations for each unique population in the dataset. Supports multiple genomic prediction models including:</p><ul><li><code>ols</code>: Ordinary Least Squares</li><li><code>ridge</code>: Ridge Regression</li><li><code>lasso</code>: Lasso Regression</li><li><code>bayesa</code>: Bayes A</li><li><code>bayesb</code>: Bayes B</li><li><code>bayesc</code>: Bayes C</li></ul><p><strong>Threading</strong></p><p>To use multiple threads, invoke Julia with: <code>julia --threads n,1</code> where n is the desired number of threads for multi-threaded processes and 1 is reserved for the Julia runtime.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(l=1_000, verbose=false); genomes.populations = StatsBase.sample(string.(&quot;pop_&quot;, 1:3), length(genomes.entries), replace=true);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);

julia&gt; phenomes = extractphenomes(trials);

julia&gt; cvs, notes = cvperpopulation(genomes=genomes, phenomes=phenomes, models=[ridge, bayesa], n_replications=2, n_folds=2, verbose=false);

julia&gt; df_across_entries, df_per_entry = tabularise(cvs);

julia&gt; sort(unique(df_across_entries.training_population))
3-element Vector{String}:
 &quot;pop_1&quot;
 &quot;pop_2&quot;
 &quot;pop_3&quot;

julia&gt; df_across_entries.training_population == df_across_entries.validation_population
true

julia&gt; idx_across = findall((df_across_entries.validation_population .== &quot;pop_1&quot;) .&amp;&amp; (df_across_entries.trait .== &quot;trait_1&quot;) .&amp;&amp; (df_across_entries.model .== &quot;bayesa&quot;) .&amp;&amp; (df_across_entries.replication .== &quot;replication_1&quot;) .&amp;&amp; (df_across_entries.fold .== &quot;fold_1&quot;));

julia&gt; idx_per = findall((df_per_entry.validation_population .== &quot;pop_1&quot;) .&amp;&amp; (df_per_entry.trait .== &quot;trait_1&quot;) .&amp;&amp; (df_per_entry.model .== &quot;bayesa&quot;) .&amp;&amp; (df_per_entry.replication .== &quot;replication_1&quot;) .&amp;&amp; (df_per_entry.fold .== &quot;fold_1&quot;));

julia&gt; abs(df_across_entries.cor[idx_across][1] - cor(df_per_entry.y_true[idx_per], df_per_entry.y_pred[idx_per])) &lt; 1e-10
true

julia&gt; summary_across, summary_per_entry = summarise(cvs);

julia&gt; size(summary_across)
(6, 8)

julia&gt; size(summary_per_entry)
(200, 8)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/cross_validation.jl#L422-L499">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.epistasisfeatures-Tuple{GBCore.Genomes, GBCore.Phenomes}" href="#GBModels.epistasisfeatures-Tuple{GBCore.Genomes, GBCore.Phenomes}"><code>GBModels.epistasisfeatures</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">epistasisfeatures(
    genomes::Genomes,
    phenomes::Phenomes;
    idx_trait::Int64 = 1,
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    transformations1::Vector{Function} = [square, invoneplus, log10epsdivlog10eps],
    transformations2::Vector{Function} = [mult, addnorm, raise],
    n_new_features_per_transformation::Int64 = 1_000,
    n_reps::Int64 = 3,
    verbose::Bool = false
)::Genomes</code></pre><p>Generate epistasis features by applying various transformations to genomic data.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: Genomic data structure containing allele frequencies</li><li><code>phenomes::Phenomes</code>: Phenotypic data structure containing trait measurements</li><li><code>idx_trait::Int64</code>: Index of the trait to analyze (default: 1)</li><li><code>idx_entries::Union{Nothing,Vector{Int64}}</code>: Indices of entries to include (default: all)</li><li><code>idx_loci_alleles::Union{Nothing,Vector{Int64}}</code>: Indices of loci/alleles to include (default: all)</li><li><code>transformations1::Vector{Function}</code>: Single-input transformation functions (default: [square, invoneplus, log10epsdivlog10eps])</li><li><code>transformations2::Vector{Function}</code>: Two-input transformation functions (default: [mult, addnorm, raise])</li><li><code>n_new_features_per_transformation::Int64</code>: Number of new features to generate per transformation (default: 1_000)</li><li><code>n_reps::Int64</code>: Number of times to repeat the transformation process (default: 3)</li><li><code>verbose::Bool</code>: Whether to display progress information (default:  false)</li></ul><p><strong>Returns</strong></p><ul><li><code>Genomes</code>: Enhanced genomic data structure with additional epistasis features</li></ul><p><strong>Description</strong></p><p>This function generates epistasis features by applying two types of transformations:</p><ol><li>Single-input transformations (transformations1) applied to individual genomic features</li><li>Two-input transformations (transformations2) applied to pairs of genomic features</li></ol><p>The transformations are repeated <code>n_reps</code> times to create a rich set of derived features.</p><p><strong>Notes</strong></p><ul><li>Ensures all generated features are within [0,1] range</li><li>Maintains dimensional consistency of input/output structures</li><li>Automatically handles entry and loci/allele subsetting</li><li>Validates input data structures before processing</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(l=1_000, verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;

julia&gt; phenomes = extractphenomes(trials);

julia&gt; genomes_plus_features = epistasisfeatures(genomes, phenomes, n_new_features_per_transformation=50, n_reps=2, verbose=false);

julia&gt; cvs, notes = cvbulk(genomes=genomes_plus_features, phenomes=phenomes, models=[ridge, lasso, bayesa], verbose=false);

julia&gt; cvs_no_epi, notes_no_epi = cvbulk(genomes=genomes, phenomes=phenomes, models=[ridge, lasso, bayesa], verbose=false);

julia&gt; df_across, df_per_entry = GBCore.tabularise(cvs);

julia&gt; df_across_no_epi, df_per_entry_no_epi = GBCore.tabularise(cvs_no_epi);

julia&gt; df_summary = combine(groupby(df_across, [:trait, :model]), [[:cor] =&gt; mean, [:cor] =&gt; std]);

julia&gt; df_summary_no_epi = combine(groupby(df_across_no_epi, [:trait, :model]), [[:cor] =&gt; mean, [:cor] =&gt; std]);

julia&gt; mean(df_summary.cor_mean) &gt; mean(df_summary_no_epi.cor_mean)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/transformation.jl#L470-L539">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.extractxyetc-Tuple{GBCore.Genomes, GBCore.Phenomes}" href="#GBModels.extractxyetc-Tuple{GBCore.Genomes, GBCore.Phenomes}"><code>GBModels.extractxyetc</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extractxyetc(
    genomes::Genomes,
    phenomes::Phenomes;
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    idx_trait::Int64 = 1,
    add_intercept::Bool = true
) -&gt; Tuple{Matrix{Float64}, Vector{Float64}, Vector{String}, Vector{String}, Vector{String}}</code></pre><p>Extract data matrices and vectors from genomic and phenotypic data for statistical analyses.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: Genomic data structure containing allele frequencies</li><li><code>phenomes::Phenomes</code>: Phenotypic data structure containing trait measurements</li><li><code>idx_entries::Union{Nothing,Vector{Int64}}</code>: Optional indices to select specific entries (default: all entries)</li><li><code>idx_loci_alleles::Union{Nothing,Vector{Int64}}</code>: Optional indices to select specific loci-alleles (default: all loci-alleles)</li><li><code>idx_trait::Int64</code>: Index of the trait to analyze (default: 1)</li><li><code>add_intercept::Bool</code>: Whether to add an intercept column to the design matrix (default: true)</li></ul><p><strong>Returns</strong></p><p>A tuple containing:</p><ol><li><code>X::Matrix{Float64}</code>: Design matrix with allele frequencies (and intercept if specified)</li><li><code>y::Vector{Float64}</code>: Response vector with phenotypic values</li><li><code>entries::Vector{String}</code>: Names of the selected entries</li><li><code>populations::Vector{String}</code>: Population identifiers for the selected entries</li><li><code>loci_alleles::Vector{String}</code>: Names of the selected loci-alleles</li></ol><p><strong>Notes</strong></p><ul><li>The function filters out entries with missing, NaN, or infinite phenotype values</li><li>Requires at least 2 valid entries after filtering</li><li>Checks for non-zero variance in the trait values</li><li>Ensures consistency between genomic and phenotypic data dimensions</li><li>Validates all index inputs are within bounds</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;

julia&gt; phenomes = extractphenomes(trials);

julia&gt; X, y, loci_alleles = extractxyetc(genomes, phenomes);

julia&gt; X == hcat(ones(length(phenomes.entries)), genomes.allele_frequencies)
true

julia&gt; y == phenomes.phenotypes[:, 1]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/prediction.jl#L1-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.grmploidyaware-Tuple{GBCore.Genomes}" href="#GBModels.grmploidyaware-Tuple{GBCore.Genomes}"><code>GBModels.grmploidyaware</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grmploidyaware(
    genomes::Genomes;
    ploidy::Int64 = 2,
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    verbose::Bool = false
)::Matrix{Float64}</code></pre><p>Generate a ploidy-aware genetic relationship matrix (GRM) based on the methods described in  Bell et al. (2017) and VanRaden et al. (2008).</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: Genomic data structure containing allele frequencies</li><li><code>ploidy::Int64</code>: Number of chromosome copies in the organism (default: 2)</li><li><code>idx_entries::Union{Nothing,Vector{Int64}}</code>: Optional indices to select specific entries (default: nothing)</li><li><code>idx_loci_alleles::Union{Nothing,Vector{Int64}}</code>: Optional indices to select specific loci/alleles (default: nothing)</li><li><code>verbose::Bool</code>: If true, displays a heatmap of the resulting GRM (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: A symmetric genetic relationship matrix with dimensions (n × n), where n is the number of entries</li></ul><p><strong>Details</strong></p><p>The function implements the following steps:</p><ol><li>Extracts and processes genomic data</li><li>Calculates allele frequencies and centers the data</li><li>Computes the GRM using VanRaden&#39;s method</li><li>Ensures matrix invertibility by adding small values to the diagonal if necessary</li></ol><p><strong>Note</strong></p><p>The diagonal elements may be slightly inflated to ensure matrix invertibility for downstream analyses.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; GRM_VanRaden = grmploidyaware(genomes);

julia&gt; size(GRM_VanRaden), issymmetric(GRM_VanRaden)
((100, 100), true)

julia&gt; det(GRM_VanRaden) &gt; eps(Float64)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/grm.jl#L79-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.grmsimple-Tuple{GBCore.Genomes}" href="#GBModels.grmsimple-Tuple{GBCore.Genomes}"><code>GBModels.grmsimple</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grmsimple(
    genomes::Genomes;
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    verbose::Bool = false
)::Matrix{Float64}</code></pre><p>Generate a simple genetic relationship matrix (GRM) from genomic data.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: Genomic data structure containing allele frequencies</li><li><code>idx_entries::Union{Nothing,Vector{Int64}}</code>: Optional indices to select specific entries/individuals</li><li><code>idx_loci_alleles::Union{Nothing,Vector{Int64}}</code>: Optional indices to select specific loci/alleles</li><li><code>verbose::Bool</code>: If true, displays a heatmap visualization of the GRM</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: A symmetric positive definite genetic relationship matrix</li></ul><p><strong>Details</strong></p><p>The function computes a genetic relationship matrix by:</p><ol><li>Converting genomic data to a numerical matrix</li><li>Computing GRM as G * G&#39; / ncol(G)</li><li>Adding small positive values to diagonal elements if necessary to ensure matrix invertibility</li></ol><p><strong>Notes</strong></p><ul><li>The resulting matrix is always symmetric</li><li>Diagonal elements may be slightly inflated to ensure matrix invertibility</li><li>The matrix dimensions will be n×n where n is the number of entries/individuals</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; GRM = grmsimple(genomes);

julia&gt; size(GRM), issymmetric(GRM)
((100, 100), true)

julia&gt; det(GRM) &gt; eps(Float64)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/grm.jl#L1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.gwaslmm-Tuple{}" href="#GBModels.gwaslmm-Tuple{}"><code>GBModels.gwaslmm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gwaslmm(
    genomes::Genomes,
    phenomes::Phenomes;
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    idx_trait::Int64 = 1,
    GRM_type::String = [&quot;simple&quot;, &quot;ploidy-aware&quot;][1],
    verbose::Bool = false
)::Fit</code></pre><p>Perform genome-wide association analysis using a linear mixed model (LMM) approach.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: Genomic data structure containing allele frequencies</li><li><code>phenomes::Phenomes</code>: Phenotypic data structure containing trait measurements</li><li><code>idx_entries::Union{Nothing,Vector{Int64}}</code>: Optional indices for subsetting entries</li><li><code>idx_loci_alleles::Union{Nothing,Vector{Int64}}</code>: Optional indices for subsetting loci/alleles</li><li><code>idx_trait::Int64</code>: Index of the trait to analyze (default: 1)</li><li><code>GRM_type::String</code>: Type of genetic relationship matrix to use:<ul><li>&quot;simple&quot;: Standard GRM calculation</li><li>&quot;ploidy-aware&quot;: Ploidy-adjusted GRM calculation</li></ul></li><li><code>verbose::Bool</code>: Whether to display progress and plots (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>Fit</code>: A structure containing GWAS results including:<ul><li><code>model</code>: Model identifier (&quot;GWAS_LMM&quot;)</li><li><code>b_hat</code>: Vector of test statistics (z-scores) for genetic markers</li></ul></li></ul><p><strong>Details</strong></p><p>The function implements a mixed model GWAS using the first principal component of the genetic  relationship matrix (GRM) as a fixed effect to control for population structure. The model  includes random effects for entries and uses REML estimation.</p><p><strong>Notes</strong></p><ul><li>Handles both diploid and polyploid data through the <code>GRM_type</code> parameter</li><li>Uses multi-threading for parallel computation of marker effects</li><li>Includes automatic convergence retry on fitting failures</li><li>Maximum fitting time per marker is limited to 60 seconds</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; ploidy = 4;

julia&gt; genomes.allele_frequencies = round.(genomes.allele_frequencies .* ploidy) ./ ploidy;

julia&gt; proportion_of_variance = zeros(9, 1); proportion_of_variance[1, 1] = 0.5;

julia&gt; trials, effects = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.05 0.00 0.00;], proportion_of_variance = proportion_of_variance, verbose=false);;

julia&gt; phenomes = extractphenomes(trials);

julia&gt; fit_1 = Suppressor.@suppress gwaslmm(genomes=genomes, phenomes=phenomes, GRM_type=&quot;simple&quot;);

julia&gt; fit_1.model
&quot;GWAS_LMM&quot;

julia&gt; fit_2 = Suppressor.@suppress gwaslmm(genomes=genomes, phenomes=phenomes, GRM_type=&quot;ploidy-aware&quot;);

julia&gt; fit_2.model
&quot;GWAS_LMM&quot;

julia&gt; findall(fit_1.b_hat .== maximum(fit_1.b_hat)) == findall(fit_2.b_hat .== maximum(fit_2.b_hat))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/gwas.jl#L259-L326">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.gwasols-Tuple{}" href="#GBModels.gwasols-Tuple{}"><code>GBModels.gwasols</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gwasols(
    genomes::Genomes,
    phenomes::Phenomes;
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    idx_trait::Int64 = 1,
    GRM_type::String = [&quot;simple&quot;, &quot;ploidy-aware&quot;][1],
    verbose::Bool = false,
)::Fit</code></pre><p>Perform genome-wide association study (GWAS) using ordinary least squares (OLS) regression with population structure correction.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: Genomic data structure containing allele frequencies</li><li><code>phenomes::Phenomes</code>: Phenotypic data structure containing trait measurements</li><li><code>idx_entries::Union{Nothing,Vector{Int64}}</code>: Optional indices to subset entries (default: all entries)</li><li><code>idx_loci_alleles::Union{Nothing,Vector{Int64}}</code>: Optional indices to subset loci/alleles (default: all loci)</li><li><code>idx_trait::Int64</code>: Index of the trait to analyze (default: 1)</li><li><code>GRM_type::String</code>: Type of genetic relationship matrix to use (&quot;simple&quot; or &quot;ploidy-aware&quot;) (default: &quot;simple&quot;)</li><li><code>verbose::Bool</code>: Whether to display progress and plots (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>Fit</code>: A structure containing GWAS results including:<ul><li><code>model</code>: Model identifier (&quot;GWAS_OLS&quot;)</li><li><code>b_hat</code>: Vector of effect size estimates/t-statistics for each marker</li><li>Additional model information</li></ul></li></ul><p><strong>Details</strong></p><p>The function implements GWAS using OLS regression while accounting for population structure through the first principal component of the genetic relationship matrix (GRM) as a covariate. Two types of GRM can be used: &quot;simple&quot; assumes diploid organisms, while &quot;ploidy-aware&quot; accounts for different ploidy levels.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; ploidy = 4;

julia&gt; genomes.allele_frequencies = round.(genomes.allele_frequencies .* ploidy) ./ ploidy;

julia&gt; proportion_of_variance = zeros(9, 1); proportion_of_variance[1, 1] = 0.5;

julia&gt; trials, effects = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.05 0.00 0.00;], proportion_of_variance = proportion_of_variance, verbose=false);;

julia&gt; phenomes = extractphenomes(trials);

julia&gt; fit_1 = gwasols(genomes=genomes, phenomes=phenomes, GRM_type=&quot;simple&quot;);

julia&gt; fit_1.model
&quot;GWAS_OLS&quot;

julia&gt; fit_2 = gwasols(genomes=genomes, phenomes=phenomes, GRM_type=&quot;ploidy-aware&quot;);

julia&gt; fit_2.model
&quot;GWAS_OLS&quot;

julia&gt; findall(fit_1.b_hat .== maximum(fit_1.b_hat)) == findall(fit_2.b_hat .== maximum(fit_2.b_hat))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/gwas.jl#L142-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.gwasprep-Tuple{}" href="#GBModels.gwasprep-Tuple{}"><code>GBModels.gwasprep</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gwasprep(
    genomes::Genomes,
    phenomes::Phenomes;
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    idx_trait::Int64 = 1,
    GRM_type::String = [&quot;simple&quot;, &quot;ploidy-aware&quot;][1],
    standardise::Bool = true,
    verbose::Bool = false,
)::Tuple{Matrix{Float64},Vector{Float64},Matrix{Float64},Fit}</code></pre><p>Prepare data matrices and structures for genome-wide association studies (GWAS).</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: Genomic data structure containing allele frequencies</li><li><code>phenomes::Phenomes</code>: Phenotypic data structure containing trait measurements</li><li><code>idx_entries::Union{Nothing,Vector{Int64}}</code>: Optional indices to subset entries (default: all entries)</li><li><code>idx_loci_alleles::Union{Nothing,Vector{Int64}}</code>: Optional indices to subset loci/alleles (default: all loci)</li><li><code>idx_trait::Int64</code>: Index of the trait to analyze (default: 1)</li><li><code>GRM_type::String</code>: Type of genetic relationship matrix to use (&quot;simple&quot; or &quot;ploidy-aware&quot;) (default: &quot;simple&quot;)</li><li><code>standardise::Bool</code>: Whether to standardize the data matrices (default: true)</li><li><code>verbose::Bool</code>: Whether to print progress information (default: false)</li></ul><p><strong>Returns</strong></p><p>A tuple containing:</p><ul><li><code>G::Matrix{Float64}</code>: Standardized allele frequency matrix</li><li><code>y::Vector{Float64}</code>: Standardized phenotype vector  </li><li><code>GRM::Matrix{Float64}</code>: Genetic relationship matrix</li><li><code>fit::Fit</code>: Initialized Fit struct for GWAS results</li></ul><p><strong>Details</strong></p><ul><li>Performs data validation and preprocessing for GWAS analysis</li><li>Removes fixed loci with no variation</li><li>Standardizes genomic and phenotypic data if requested</li><li>Constructs appropriate genetic relationship matrix</li><li>Initializes output structure for association results</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; ploidy = 4;

julia&gt; genomes.allele_frequencies = round.(genomes.allele_frequencies .* ploidy) ./ ploidy;

julia&gt; proportion_of_variance = zeros(9, 1); proportion_of_variance[1, 1] = 0.5;

julia&gt; trials, effects = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.05 0.00 0.00;], proportion_of_variance = proportion_of_variance, verbose=false);;

julia&gt; phenomes = extractphenomes(trials);

julia&gt; G, y, GRM, fit = gwasprep(genomes=genomes, phenomes=phenomes);

julia&gt; sum(abs.(mean(G, dims=1)[1,:]) .&lt; 1e-10) == size(G, 2)
true

julia&gt; sum(abs.(std(G, dims=1)[1,:] .- 1) .&lt; 1e-10) == size(G, 2)
true

julia&gt; (abs(mean(y)) &lt; 1e-10, abs(std(y) - 1) &lt; 1e-10)
(true, true)

julia&gt; size(G, 1) == length(y)
true

julia&gt; (size(G, 1), length(y)) == size(GRM)
true

julia&gt; length(fit.entries) == length(y)
true

julia&gt; length(fit.b_hat) == size(G, 2)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/gwas.jl#L1-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.gwasreml-Tuple{}" href="#GBModels.gwasreml-Tuple{}"><code>GBModels.gwasreml</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gwasreml(
    genomes::Genomes,
    phenomes::Phenomes;
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    idx_trait::Int64 = 1,
    GRM_type::String = &quot;simple&quot;,
    verbose::Bool = false
)::Fit</code></pre><p>Performs genome-wide association analysis using restricted maximum likelihood estimation (REML).</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: Genomic data structure containing allele frequencies</li><li><code>phenomes::Phenomes</code>: Phenotypic data structure containing trait measurements</li><li><code>idx_entries::Union{Nothing,Vector{Int64}}</code>: Optional indices to subset entries (default: nothing)</li><li><code>idx_loci_alleles::Union{Nothing,Vector{Int64}}</code>: Optional indices to subset loci/alleles (default: nothing)</li><li><code>idx_trait::Int64</code>: Index of the trait to analyze (default: 1)</li><li><code>GRM_type::String</code>: Type of genetic relationship matrix to use, either &quot;simple&quot; or &quot;ploidy-aware&quot; (default: &quot;simple&quot;)</li><li><code>verbose::Bool</code>: Whether to display progress and plots (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>::Fit</code>: A Fit struct containing GWAS results, including effect estimates and test statistics</li></ul><p><strong>Details</strong></p><p>Implements the REML log-likelihood calculation for a mixed model of the form: y = Xβ + Zu + e where:</p><ul><li>β are fixed effects</li><li>u are random genetic effects with u ~ N(0, σ²_u * GRM)</li><li>e are residual effects with e ~ N(0, σ²_e * I)</li></ul><p>The function constructs the variance-covariance matrices and computes the REML transformation to obtain the log-likelihood value used in variance component estimation.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(l=1_000, verbose=false);

julia&gt; ploidy = 4;

julia&gt; genomes.allele_frequencies = round.(genomes.allele_frequencies .* ploidy) ./ ploidy;

julia&gt; proportion_of_variance = zeros(9, 1); proportion_of_variance[1, 1] = 0.5;

julia&gt; trials, effects = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.05 0.00 0.00;], proportion_of_variance = proportion_of_variance, verbose=false);;

julia&gt; phenomes = extractphenomes(trials);

julia&gt; fit_1 = gwasreml(genomes=genomes, phenomes=phenomes, GRM_type=&quot;simple&quot;);

julia&gt; fit_1.model
&quot;GWAS_REML&quot;

julia&gt; fit_2 = gwasreml(genomes=genomes, phenomes=phenomes, GRM_type=&quot;ploidy-aware&quot;);

julia&gt; fit_2.model
&quot;GWAS_REML&quot;

julia&gt; findall(fit_1.b_hat .== maximum(fit_1.b_hat)) == findall(fit_2.b_hat .== maximum(fit_2.b_hat))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/gwas.jl#L483-L546">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.heritabilitynarrow_sense-Tuple{Vector{Float64}, Vector{Float64}}" href="#GBModels.heritabilitynarrow_sense-Tuple{Vector{Float64}, Vector{Float64}}"><code>GBModels.heritabilitynarrow_sense</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">heritabilitynarrow_sense(y_true::Vector{Float64}, y_pred::Vector{Float64})::Float64</code></pre><p>Calculate narrow-sense heritability (h²) from true and predicted phenotypic values.</p><p>Narrow-sense heritability is the proportion of phenotypic variance that can be attributed to additive genetic effects. It is calculated as the ratio of additive genetic variance (s²a) to total phenotypic variance (s²a + s²e).</p><p><strong>Arguments</strong></p><ul><li><code>y_true::Vector{Float64}</code>: Vector of observed/true phenotypic values</li><li><code>y_pred::Vector{Float64}</code>: Vector of predicted genetic values</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: Narrow-sense heritability (h²) value between 0 and 1</li></ul><p><strong>Details</strong></p><ul><li>Returns 0.0 if variance of either input vector is near zero (&lt; 1e-10)</li><li>Additive genetic variance (s²a) is estimated from variance of predictions</li><li>Environmental variance (s²e) is estimated from variance of residuals</li><li>Result is bounded between 0 and 1</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/metrics.jl#L32-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.invoneplus-Tuple{Any}" href="#GBModels.invoneplus-Tuple{Any}"><code>GBModels.invoneplus</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">invoneplus(x) = 1 / (1 + x)</code></pre><p>This function takes a number, adds one and inverts it. A member of the set of endofunctions defined in GBModels.jl for building non-linear genomic prediction models. Both input and ouput range between zero and one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/transformation.jl#L11-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.lasso-Tuple{}" href="#GBModels.lasso-Tuple{}"><code>GBModels.lasso</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lasso(;
    genomes::Genomes,
    phenomes::Phenomes,
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    idx_trait::Int64 = 1,
    verbose::Bool = false,
)::Fit</code></pre><p>Fits a LASSO (Least Absolute Shrinkage and Selection Operator) regression model with L1 regularization  for genomic prediction.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: Genomic data structure containing allele frequencies</li><li><code>phenomes::Phenomes</code>: Phenotypic data structure containing trait measurements</li><li><code>idx_entries::Union{Nothing,Vector{Int64}}</code>: Optional indices to select specific entries/individuals</li><li><code>idx_loci_alleles::Union{Nothing,Vector{Int64}}</code>: Optional indices to select specific loci-alleles</li><li><code>idx_trait::Int64</code>: Index of the trait to analyze (default: 1)</li><li><code>verbose::Bool</code>: If true, prints diagnostic plots and additional information (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>Fit</code>: A fitted model object containing:<ul><li><code>model</code>: Model identifier (&quot;ols&quot;)</li><li><code>b_hat</code>: Estimated regression coefficients</li><li><code>b_hat_labels</code>: Labels for the coefficients</li><li><code>trait</code>: Name of the analyzed trait</li><li><code>entries</code>: Entry identifiers</li><li><code>populations</code>: Population identifiers</li><li><code>y_true</code>: Observed phenotypic values</li><li><code>y_pred</code>: Predicted phenotypic values</li><li><code>metrics</code>: Dictionary of performance metrics</li></ul></li></ul><p><strong>Details</strong></p><p>The function implements LASSO regression using the GLMNet package, which performs automatic  feature selection through L1 regularization. The optimal regularization parameter (λ) is  selected using cross-validation to minimize prediction error while promoting sparsity in  the coefficients.</p><p><strong>Notes</strong></p><ul><li>Standardisation is disabled by default because the allele frequencies across loci are comparable as they all range from zero to one</li><li>The model includes an intercept term</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;

julia&gt; phenomes = extractphenomes(trials);

julia&gt; fit = lasso(genomes=genomes, phenomes=phenomes);

julia&gt; fit.model == &quot;lasso&quot;
true

julia&gt; fit.metrics[&quot;cor&quot;] &gt; 0.50
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/linear.jl#L242-L301">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.log10epsdivlog10eps-Tuple{Any}" href="#GBModels.log10epsdivlog10eps-Tuple{Any}"><code>GBModels.log10epsdivlog10eps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">log10epsdivlog10eps(x) = (log10(abs(x) + eps(Float64))) / log10(eps(Float64))</code></pre><p>This function takes a number, adds a very tiny value, takes the log10, and divide it by the log10 of the same very tiny value. A member of the set of endofunctions defined in GBModels.jl for building non-linear genomic prediction models. Both input and ouput range between zero and one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/transformation.jl#L20-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.loglikreml-Tuple{Vector{Float64}, Tuple{Vector{Float64}, Matrix{Float64}, Matrix{Float64}}}" href="#GBModels.loglikreml-Tuple{Vector{Float64}, Tuple{Vector{Float64}, Matrix{Float64}, Matrix{Float64}}}"><code>GBModels.loglikreml</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loglikreml(θ::Vector{Float64}, data::Tuple{Vector{Float64},Matrix{Float64},Matrix{Float64}})::Float64</code></pre><p>Calculate the restricted maximum likelihood (REML) log-likelihood for a mixed linear model.</p><p><strong>Arguments</strong></p><ul><li><code>θ::Vector{Float64}</code>: Vector of variance components [σ²<em>e, σ²</em>u] where:<ul><li>σ²_e is the residual variance</li><li>σ²_u is the genetic variance</li></ul></li><li><code>data::Tuple{Vector{Float64},Matrix{Float64},Matrix{Float64}}</code>: Tuple containing:<ul><li>y: Vector of phenotypic observations</li><li>X: Design matrix for fixed effects</li><li>GRM: Genomic relationship matrix</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The REML log-likelihood value. Returns <code>Inf</code> if matrix operations fail.</li></ul><p><strong>Details</strong></p><p>Implements the REML log-likelihood calculation for a mixed model of the form: y = Xβ + Zu + e where:</p><ul><li>β are fixed effects</li><li>u are random genetic effects with u ~ N(0, σ²_u * GRM)</li><li>e are residual effects with e ~ N(0, σ²_e * I)</li></ul><p>The function constructs the variance-covariance matrices and computes the REML transformation to obtain the log-likelihood value used in variance component estimation.</p><p><strong>Examples</strong></p><p>```jldoctest; setup = :(using GBCore, GBModels, LinearAlgebra, StatsBase) julia&gt; genomes = GBCore.simulategenomes(verbose=false);</p><p>julia&gt; ploidy = 4;</p><p>julia&gt; genomes.allele<em>frequencies = round.(genomes.allele</em>frequencies .* ploidy) ./ ploidy;</p><p>julia&gt; proportion<em>of</em>variance = zeros(9, 1); proportion<em>of</em>variance[1, 1] = 0.5;</p><p>julia&gt; trials, effects = GBCore.simulatetrials(genomes=genomes, n<em>years=1, n</em>seasons=1, n<em>harvests=1, n</em>sites=1, n<em>replications=1, f</em>add<em>dom</em>epi=[0.05 0.00 0.00;], proportion<em>of</em>variance = proportion<em>of</em>variance, verbose=false);;</p><p>julia&gt; phenomes = extractphenomes(trials);</p><p>julia&gt; G, y, GRM, fit = gwasprep(genomes=genomes, phenomes=phenomes);</p><p>julia&gt; loglik = loglikreml([0.53, 0.15], (y, hcat(ones(length(y)), G[:, 1]), GRM));</p><p>julia&gt; loglik &lt; 100 true</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/gwas.jl#L399-L447">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.metrics-Tuple{Vector{Float64}, Vector{Float64}}" href="#GBModels.metrics-Tuple{Vector{Float64}, Vector{Float64}}"><code>GBModels.metrics</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">metrics(y_true::Vector{Float64}, y_pred::Vector{Float64})::Dict{String,Float64}</code></pre><p>Calculate various metrics comparing predicted vs true values.</p><p>Returns a dictionary containing the following metrics:</p><ul><li><code>cor</code>: Pearson correlation coefficient</li><li><code>mad</code>: Mean absolute deviation</li><li><code>msd</code>: Mean squared deviation</li><li><code>rmsd</code>: Root mean squared deviation  </li><li><code>nrmsd</code>: Normalized root mean squared deviation</li><li><code>euc</code>: Euclidean distance</li><li><code>jac</code>: Jaccard distance</li><li><code>tvar</code>: Total variation distance</li><li><code>h²</code>: Narrow-sense heritability</li></ul><p><strong>Arguments</strong></p><ul><li><code>y_true::Vector{Float64}</code>: Vector of true/observed values</li><li><code>y_pred::Vector{Float64}</code>: Vector of predicted values</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{String,Float64}</code>: Dictionary mapping metric names to their calculated values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/metrics.jl#L72-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.mlp-Tuple{}" href="#GBModels.mlp-Tuple{}"><code>GBModels.mlp</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mlp(;
    genomes::Genomes,
    phenomes::Phenomes,
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    idx_trait::Int64 = 1,
    n_layers::Int64 = 3,
    activation::Function = relu,
    max_n_nodes::Int64 = 256,
    n_nodes_droprate::Float64 = 0.50,
    dropout_droprate::Float64 = 0.25,
    n_epochs::Int64 = 100_000,
    use_cpu::Bool = false,
    seed::Int64 = 123,
    verbose::Bool = false
)::Fit</code></pre><p>Fit a genomic prediction model using a multi-layer perceptron (MLP) neural network with Lux.jl.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: Genetic information of the population</li><li><code>phenomes::Phenomes</code>: Phenotypic data of the population</li><li><code>idx_entries::Union{Nothing,Vector{Int64}}</code>: Indices of entries to include in the analysis</li><li><code>idx_loci_alleles::Union{Nothing,Vector{Int64}}</code>: Indices of loci-alleles to include</li><li><code>idx_trait::Int64</code>: Index of the trait to analyze</li><li><code>n_layers::Int64</code>: Number of hidden layers in the neural network</li><li><code>activation::Function</code>: Activation function for the neural network layers (default: relu)</li><li><code>max_n_nodes::Int64</code>: Maximum number of nodes in the first hidden layer</li><li><code>n_nodes_droprate::Float64</code>: Rate at which number of nodes decreases between layers</li><li><code>dropout_droprate::Float64</code>: Initial dropout rate for regularization, subsequent layers have proportionally decreasing rates</li><li><code>n_epochs::Int64</code>: Number of training epochs</li><li><code>use_cpu::Bool</code>: If true, forces CPU usage instead of GPU</li><li><code>seed::Int64</code>: Random seed for reproducibility</li><li><code>verbose::Bool</code>: If true, prints training progress and final metrics</li></ul><p><strong>Returns</strong></p><ul><li><code>Fit</code>: A fitted model object containing:<ul><li><code>y_pred</code>: Predicted values</li><li><code>y_true</code>: Observed values</li><li><code>b_hat</code>: Model coefficients (placeholder zeros for MLP)</li><li><code>lux_model</code>: The trained Lux neural network model</li><li><code>metrics</code>: Performance metrics</li><li>Additional metadata about the model fit</li></ul></li></ul><p><strong>Details</strong></p><p>The neural network architecture is constructed dynamically based on input parameters:</p><ul><li>For 1 layer: Direct input to output mapping</li><li>For 2 layers: Input → max<em>n</em>nodes → output</li><li>For 3+ layers: Input → max<em>n</em>nodes → progressively smaller layers → output with optional dropout between layers</li></ul><p>Training uses the Adam optimizer with a learning rate of 0.0001 and MSE loss function.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(l=1_000, verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);

julia&gt; phenomes = extractphenomes(trials);

julia&gt; fit = Suppressor.@suppress mlp(genomes=genomes, phenomes=phenomes, n_epochs=1_000, use_cpu=true, verbose=false);

julia&gt; fit.metrics[&quot;cor&quot;] &gt;= 0.2
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/dl.jl#L1-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.mult-Tuple{Any, Any}" href="#GBModels.mult-Tuple{Any, Any}"><code>GBModels.mult</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mult(x, y) = x * y</code></pre><p>This function takes two numbers and multiplies them together. A member of the set of endofunctions defined in GBModels.jl for building non-linear genomic prediction models. Inputs and ouput range between zero and one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/transformation.jl#L29-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.ols-Tuple{}" href="#GBModels.ols-Tuple{}"><code>GBModels.ols</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ols(;
    genomes::Genomes,
    phenomes::Phenomes,
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    idx_trait::Int64 = 1,
    verbose::Bool = false
)::Fit</code></pre><p>Fits an ordinary least squares (OLS) regression model to genomic and phenotypic data.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: Genomic data structure containing allele frequencies</li><li><code>phenomes::Phenomes</code>: Phenotypic data structure containing trait measurements</li><li><code>idx_entries::Union{Nothing,Vector{Int64}}</code>: Optional indices to select specific entries (default: all entries)</li><li><code>idx_loci_alleles::Union{Nothing,Vector{Int64}}</code>: Optional indices to select specific loci-alleles (default: all loci-alleles)</li><li><code>idx_trait::Int64</code>: Index of the trait to analyze (default: 1)</li><li><code>verbose::Bool</code>: If true, displays diagnostic plots and performance metrics (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>Fit</code>: A fitted model object containing:<ul><li><code>model</code>: Model identifier (&quot;ols&quot;)</li><li><code>b_hat</code>: Estimated regression coefficients</li><li><code>b_hat_labels</code>: Labels for the coefficients</li><li><code>trait</code>: Name of the analyzed trait</li><li><code>entries</code>: Entry identifiers</li><li><code>populations</code>: Population identifiers</li><li><code>y_true</code>: Observed phenotypic values</li><li><code>y_pred</code>: Predicted phenotypic values</li><li><code>metrics</code>: Dictionary of performance metrics</li></ul></li></ul><p><strong>Description</strong></p><p>Performs ordinary least squares regression on genomic data to predict phenotypic values. The model includes an intercept term and estimates effects for each locus-allele combination.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;

julia&gt; phenomes = extractphenomes(trials);

julia&gt; fit = ols(genomes=genomes, phenomes=phenomes);

julia&gt; fit.model == &quot;ols&quot;
true

julia&gt; fit.metrics[&quot;cor&quot;] &gt; 0.50
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/linear.jl#L1-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.pearsonscorrelation-Tuple{Vector{Float64}, Vector{Float64}}" href="#GBModels.pearsonscorrelation-Tuple{Vector{Float64}, Vector{Float64}}"><code>GBModels.pearsonscorrelation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pearsonscorrelation(y_true::Vector{Float64}, y_pred::Vector{Float64})::Float64</code></pre><p>Calculate the Pearson correlation coefficient between two vectors.</p><p>The Pearson correlation coefficient measures the linear correlation between two variables, giving a value between -1 and +1, where:</p><ul><li>+1 represents perfect positive correlation</li><li>0 represents no linear correlation</li><li>-1 represents perfect negative correlation</li></ul><p><strong>Arguments</strong></p><ul><li><code>y_true::Vector{Float64}</code>: Vector of true/actual values</li><li><code>y_pred::Vector{Float64}</code>: Vector of predicted/estimated values</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: Pearson correlation coefficient</li></ul><p><strong>Notes</strong></p><ul><li>Returns 0.0 if the variance of either input vector is less than 1e-10</li><li>Uses <code>1 - correlation distance</code> from Distances.jl package</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/metrics.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.predict-Tuple{}" href="#GBModels.predict-Tuple{}"><code>GBModels.predict</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">predict(; fit::Fit, genomes::Genomes, idx_entries::Vector{Int64})::Vector{Float64}</code></pre><p>Calculate predicted phenotypes using a fitted genomic prediction model.</p><p><strong>Arguments</strong></p><ul><li><code>fit::Fit</code>: A fitted genomic prediction model containing coefficients and model information</li><li><code>genomes::Genomes</code>: Genomic data containing allele frequencies</li><li><code>idx_entries::Vector{Int64}</code>: Vector of indices specifying which entries to predict</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: Predicted phenotypic values for the specified entries</li></ul><p><strong>Details</strong></p><p>Supports various linear genomic prediction models including:</p><ul><li>OLS (Ordinary Least Squares)</li><li>Ridge Regression</li><li>LASSO</li><li>Bayes A</li><li>Bayes B</li><li>Bayes C</li></ul><p>The function validates input dimensions and compatibility between the fitted model and genomic data before making predictions.</p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the Fit or Genomes structs are corrupted</li><li><code>ArgumentError</code>: If entry indices are out of bounds</li><li><code>ArgumentError</code>: If loci-alleles in the fitted model don&#39;t match the validation set</li><li><code>ArgumentError</code>: If the genomic prediction model is not recognized</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);

julia&gt; phenomes = extractphenomes(trials);

julia&gt; fit = ridge(genomes=genomes, phenomes=phenomes, idx_entries=collect(1:90));

julia&gt; y_hat = GBModels.predict(fit=fit, genomes=genomes, idx_entries=collect(91:100));

julia&gt; cor(phenomes.phenotypes[91:100, 1], y_hat) &gt; 0.5
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/prediction.jl#L142-L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.raise-Tuple{Any, Any}" href="#GBModels.raise-Tuple{Any, Any}"><code>GBModels.raise</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">raise(x, y) = x^y</code></pre><p>This function raises the first value to the power of the second value. A member of the set of endofunctions defined in GBModels.jl for building non-linear genomic prediction models. Inputs and ouput range between zero and one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/transformation.jl#L47-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.reconstitutefeatures-Tuple{GBCore.Genomes}" href="#GBModels.reconstitutefeatures-Tuple{GBCore.Genomes}"><code>GBModels.reconstitutefeatures</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reconstitutefeatures(
    genomes::Genomes;
    feature_names::Vector{String},
    verbose::Bool = false
)::Genomes</code></pre><p>Reconstruct epistasis features from a Genomes struct using feature names that encode the transformations applied.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: Genomic data structure containing allele frequencies</li><li><code>feature_names::Vector{String}</code>: Vector of feature names containing encoded transformation information</li><li><code>verbose::Bool</code>: Whether to show progress bar during reconstruction (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>Genomes</code>: A new Genomes struct with reconstructed epistasis features</li></ul><p><strong>Details</strong></p><p>The function parses the feature names to determine which transformations were applied and reconstructs the features by applying these transformations to the original genomic data. Feature names should  contain the transformation operations in a format that can be parsed and evaluated.</p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the input Genomes struct is corrupted (invalid dimensions)</li><li><code>ErrorException</code>: If feature reconstruction fails</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(l=1_000, verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;

julia&gt; phenomes = extractphenomes(trials);

julia&gt; genomes_epifeat = epistasisfeatures(genomes, phenomes, n_new_features_per_transformation=50, n_reps=2, verbose=false);

julia&gt; feature_names = genomes_epifeat.loci_alleles;

julia&gt; genomes_epifeat_reconstructed = reconstitutefeatures(genomes, feature_names=feature_names);

julia&gt; genomes_epifeat == genomes_epifeat_reconstructed
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/transformation.jl#L686-L729">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.ridge-Tuple{}" href="#GBModels.ridge-Tuple{}"><code>GBModels.ridge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ridge(;
    genomes::Genomes,
    phenomes::Phenomes,
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    idx_trait::Int64 = 1,
    verbose::Bool = false
)::Fit</code></pre><p>Fit a ridge (L2) regression model to genomic data. Ridge regression adds an L2 regularization term  to the ordinary least squares objective function, which helps prevent overfitting and handles  multicollinearity in the predictors.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: Genomic data structure containing allele frequencies</li><li><code>phenomes::Phenomes</code>: Phenotypic data structure containing trait measurements</li><li><code>idx_entries::Union{Nothing,Vector{Int64}}</code>: Optional indices to subset specific entries/individuals</li><li><code>idx_loci_alleles::Union{Nothing,Vector{Int64}}</code>: Optional indices to subset specific loci-alleles</li><li><code>idx_trait::Int64</code>: Index of the trait to analyze (default: 1)</li><li><code>verbose::Bool</code>: If true, prints diagnostic plots and additional information (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>Fit</code>: A fitted model object containing:<ul><li><code>model</code>: Model identifier (&quot;ols&quot;)</li><li><code>b_hat</code>: Estimated regression coefficients</li><li><code>b_hat_labels</code>: Labels for the coefficients</li><li><code>trait</code>: Name of the analyzed trait</li><li><code>entries</code>: Entry identifiers</li><li><code>populations</code>: Population identifiers</li><li><code>y_true</code>: Observed phenotypic values</li><li><code>y_pred</code>: Predicted phenotypic values</li><li><code>metrics</code>: Dictionary of performance metrics</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>Uses cross-validation to select the optimal regularization parameter (λ)</li><li>Standardizes predictors before fitting</li><li>Includes an intercept term in the model</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;

julia&gt; phenomes = extractphenomes(trials);

julia&gt; fit = ridge(genomes=genomes, phenomes=phenomes);

julia&gt; fit.model == &quot;ridge&quot;
true

julia&gt; fit.metrics[&quot;cor&quot;] &gt; 0.50
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/linear.jl#L106-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.square-Tuple{Any}" href="#GBModels.square-Tuple{Any}"><code>GBModels.square</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">square(x) = x^2</code></pre><p>This function takes a number and squares it. A member of the set of endofunctions defined in GBModels.jl for building non-linear genomic prediction models. Both input and ouput range between zero and one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/transformation.jl#L2-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.transform1-Tuple{Function, GBCore.Genomes, GBCore.Phenomes}" href="#GBModels.transform1-Tuple{Function, GBCore.Genomes, GBCore.Phenomes}"><code>GBModels.transform1</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transform1(
    f::Function,
    genomes::Genomes,
    phenomes::Phenomes;
    idx_trait::Int64 = 1,
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    n_new_features_per_transformation::Int64 = 1_000,
    ϵ::Float64 = eps(Float64),
    use_abs::Bool = false,
    σ²_threshold::Float64 = 0.01,
    verbose::Bool = false
)::Genomes</code></pre><p>Apply a transformation function to each allele frequency in genomic data while considering their effects on phenotypes.</p><p><strong>Arguments</strong></p><ul><li><code>f::Function</code>: Transformation function to apply to allele frequencies</li><li><code>genomes::Genomes</code>: Input genomic data structure</li><li><code>phenomes::Phenomes</code>: Corresponding phenotypic data structure</li></ul><p><strong>Keywords</strong></p><ul><li><code>idx_trait::Int64</code>: Index of the trait to analyze (default: 1)</li><li><code>idx_entries::Union{Nothing,Vector{Int64}}</code>: Indices of entries to include (default: all)</li><li><code>idx_loci_alleles::Union{Nothing,Vector{Int64}}</code>: Indices of loci-alleles to include (default: all)</li><li><code>n_new_features_per_transformation::Int64</code>: Maximum number of transformed features to retain (default: 1000)</li><li><code>ϵ::Float64</code>: Small value added to prevent numerical issues (default: machine epsilon)</li><li><code>use_abs::Bool</code>: Whether to use absolute values before transformation (default: false)</li><li><code>σ²_threshold::Float64</code>: Minimum variance threshold for considering a locus (default: 0.01)</li><li><code>verbose::Bool</code>: Whether to show progress and plots (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>Genomes</code>: A new Genomes object containing the transformed allele frequencies</li></ul><p><strong>Details</strong></p><p>The function performs the following steps:</p><ol><li>Extracts allele frequencies and phenotypic data</li><li>Applies the transformation function to each locus</li><li>Estimates effects using ordinary least squares</li><li>Selects the most important transformed features</li><li>Cleans numerical artifacts (values near 0 or 1)</li></ol><p><strong>Notes</strong></p><ul><li>Use named functions to ensure transformations can be reconstructed from <code>loci_alleles</code></li><li>The function adds <code>ϵ</code> to frequencies to prevent numerical issues</li><li>Features with variance below <code>σ²_threshold</code> are skipped</li><li>The output contains at most <code>n_new_features_per_transformation</code> features</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(l=1_000, verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;

julia&gt; phenomes = extractphenomes(trials);

julia&gt; genomes_transformed = transform1(x -&gt; x^2, genomes, phenomes);

julia&gt; idx = findall(genomes.loci_alleles .== split(split(replace(genomes_transformed.loci_alleles[1], &quot;)&quot; =&gt; &quot;&quot;), &quot;(&quot;)[2], &quot;,&quot;)[1])[1];

julia&gt; mean(sqrt.(genomes_transformed.allele_frequencies[:, 1]) .- genomes.allele_frequencies[:, idx]) &lt; 1e-10
true

julia&gt; squareaddpi(x) = x^2 + pi;

julia&gt; genomes_transformed = transform1(squareaddpi, genomes, phenomes);

julia&gt; idx = findall(genomes.loci_alleles .== split(split(replace(genomes_transformed.loci_alleles[1], &quot;)&quot; =&gt; &quot;&quot;), &quot;(&quot;)[2], &quot;,&quot;)[1])[1];

julia&gt; mean(squareaddpi.(genomes.allele_frequencies[:, idx]) .- genomes_transformed.allele_frequencies[:, 1]) &lt; 1e-10
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/transformation.jl#L56-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.transform2-Tuple{Function, GBCore.Genomes, GBCore.Phenomes}" href="#GBModels.transform2-Tuple{Function, GBCore.Genomes, GBCore.Phenomes}"><code>GBModels.transform2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transform2(
    f::Function,
    genomes::Genomes,
    phenomes::Phenomes;
    idx_trait::Int64 = 1,
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    n_new_features_per_transformation::Int64 = 1_000,
    ϵ::Float64 = eps(Float64),
    use_abs::Bool = false,
    σ²_threshold::Float64 = 0.01,
    commutative::Bool = false,
    verbose::Bool = false
)::Genomes</code></pre><p>Apply a transformation function to pairs of allele frequencies in genomic data while considering their effects on phenotypes.</p><p><strong>Arguments</strong></p><ul><li><code>f::Function</code>: Transformation function to apply to pairs of allele frequencies</li><li><code>genomes::Genomes</code>: Input genomic data structure</li><li><code>phenomes::Phenomes</code>: Corresponding phenotypic data structure</li><li><code>idx_trait::Int64</code>: Index of the trait to analyze (default: 1)</li><li><code>idx_entries::Union{Nothing,Vector{Int64}}</code>: Subset of entries to include (default: all)</li><li><code>idx_loci_alleles::Union{Nothing,Vector{Int64}}</code>: Subset of loci-alleles to include (default: all)</li><li><code>n_new_features_per_transformation::Int64</code>: Maximum number of transformed features to retain (default: 1000)</li><li><code>ϵ::Float64</code>: Small value added to frequencies to avoid numerical issues (default: machine epsilon)</li><li><code>use_abs::Bool</code>: Whether to use absolute values of frequencies (default: false)</li><li><code>σ²_threshold::Float64</code>: Minimum variance threshold for considering loci (default: 0.01)</li><li><code>commutative::Bool</code>: Whether the transformation function is commutative (default: false)</li><li><code>verbose::Bool</code>: Whether to display progress and diagnostics (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>Genomes</code>: A new Genomes object containing the transformed features</li></ul><p><strong>Details</strong></p><p>The function performs the following steps:</p><ol><li>Extracts allele frequencies and phenotypic data</li><li>Applies the transformation function to all possible pairs of allele freuqencies (i.e., locus-allele combinations)</li><li>Estimates effects using ordinary least squares</li><li>Selects the most important transformed features</li><li>Cleans numerical artifacts (values near 0 or 1)</li></ol><p><strong>Notes</strong></p><ul><li>Use named functions to ensure transformations can be reconstructed from <code>loci_alleles</code></li><li>The function adds <code>ϵ</code> to frequencies to prevent numerical issues</li><li>Features with variance below <code>σ²_threshold</code> are skipped</li><li>The output contains at most <code>n_new_features_per_transformation</code> features</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(l=1_000, verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;

julia&gt; phenomes = extractphenomes(trials);

julia&gt; genomes_transformed = transform2((x,y) -&gt; (x^2 + sqrt(y)) / 2, genomes, phenomes);

julia&gt; idx_1 = findall(genomes.loci_alleles .== split(split(replace(genomes_transformed.loci_alleles[1], &quot;)&quot; =&gt; &quot;&quot;), &quot;(&quot;)[2], &quot;,&quot;)[1])[1];

julia&gt; idx_2 = findall(genomes.loci_alleles .== split(split(replace(genomes_transformed.loci_alleles[1], &quot;)&quot; =&gt; &quot;&quot;), &quot;(&quot;)[2], &quot;,&quot;)[2])[1];

julia&gt; mean((genomes.allele_frequencies[:,idx_1].^2 .+ sqrt.(genomes.allele_frequencies[:,idx_2])) ./ 2 .- genomes_transformed.allele_frequencies[:,1]) &lt; 1e-10
true

julia&gt; raisexbyythenlog(x, y) = log(abs(x^y));

julia&gt; genomes_transformed = transform2(raisexbyythenlog, genomes, phenomes);

julia&gt; idx_1 = findall(genomes.loci_alleles .== split(split(replace(genomes_transformed.loci_alleles[1], &quot;)&quot; =&gt; &quot;&quot;), &quot;(&quot;)[2], &quot;,&quot;)[1])[1];

julia&gt; idx_2 = findall(genomes.loci_alleles .== split(split(replace(genomes_transformed.loci_alleles[1], &quot;)&quot; =&gt; &quot;&quot;), &quot;(&quot;)[2], &quot;,&quot;)[2])[1];

julia&gt; mean(raisexbyythenlog.(genomes.allele_frequencies[:,idx_1], genomes.allele_frequencies[:,idx_2]) .- genomes_transformed.allele_frequencies[:,1]) &lt; 1e-10
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/transformation.jl#L241-L318">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.turing_bayesG-Tuple{Any, Any}" href="#GBModels.turing_bayesG-Tuple{Any, Any}"><code>GBModels.turing_bayesG</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Turing specification of Bayesian linear regression using a Gaussian prior with common variance</p><p><strong>Example usage</strong></p><pre><code class="language-julia hljs"># Benchmarking
genomes = GBCore.simulategenomes(n=10, l=100)
trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])
phenomes = extractphenomes(trials)
G::Matrix{Float64} = genomes.allele_frequencies
y::Vector{Float64} = phenomes.phenotypes[:, 1]
model = turing_bayesG(G, y)
benchmarks = TuringBenchmarking.benchmark_model(
    model;
    # Check correctness of computations
    check=true,
    # Automatic differentiation backends to check and benchmark
    adbackends=[:forwarddiff, :reversediff, :reversediff_compiled, :zygote]
)

# Test more loci
genomes = GBCore.simulategenomes(n=10, l=10_000)
trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])
phenomes = extractphenomes(trials)
G::Matrix{Float64} = genomes.allele_frequencies
y::Vector{Float64} = phenomes.phenotypes[:, 1]
# Check for uninferred types in the model
@code_warntype model = turing_bayesG(G, y)
# Fit
model = turing_bayesG(G, y)
# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below
rng::TaskLocalRNG = Random.seed!(123)
niter::Int64 = 1_500
nburnin::Int64 = 500
@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.65, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);
# @time chain = Turing.sample(rng, model, HMC(0.05, 10; adtype=AutoReverseDiff(compile=true)), niter, progress=true);
p = Plots.histogram(chain[:σ²])
Plots.gui(p)
# Use the mean paramter values after 150 burn-in iterations
params = Turing.get_params(chain[501:end, :, :]);
b_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);
# Assess prediction accuracy
y_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;
UnicodePlots.scatterplot(y, y_pred)
performance::Dict{String, Float64} = metrics(y, y_pred)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/bayes.jl#L231-L277">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.turing_bayesG_logit-Tuple{Any, Any}" href="#GBModels.turing_bayesG_logit-Tuple{Any, Any}"><code>GBModels.turing_bayesG_logit</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Turing specification of Bayesian logistic regression using a Gaussian prior with common variance</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/bayes.jl#L858-L860">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.turing_bayesGs-Tuple{Any, Any}" href="#GBModels.turing_bayesGs-Tuple{Any, Any}"><code>GBModels.turing_bayesGs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Turing specification of Bayesian linear regression using a Gaussian prior with varying variances</p><p><strong>Example usage</strong></p><pre><code class="language-julia hljs"># Simulate data
genomes = GBCore.simulategenomes(n=10, l=100)
trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])
phenomes = extractphenomes(trials)
# Extract genotype and phenotype data
G::Matrix{Float64} = genomes.allele_frequencies
y::Vector{Float64} = phenomes.phenotypes[:, 1]
# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.
model = turing_bayesGs(G, y)
# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below
rng::TaskLocalRNG = Random.seed!(123)
niter::Int64 = 1_500
nburnin::Int64 = 500
@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);
# Use the mean paramter values after 150 burn-in iterations
params = Turing.get_params(chain[150:end, :, :]);
b_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);
# Assess prediction accuracy
y_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;
UnicodePlots.scatterplot(y, y_pred)
performance::Dict{String, Float64} = metrics(y, y_pred)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/bayes.jl#L294-L321">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.turing_bayesGπ-Tuple{Any, Any}" href="#GBModels.turing_bayesGπ-Tuple{Any, Any}"><code>GBModels.turing_bayesGπ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Turing specification of Bayesian linear regression using a Gaussian prior with a point mass at zero and common variance</p><p><strong>Example usage</strong></p><pre><code class="language-julia hljs"># Simulate data
genomes = GBCore.simulategenomes(n=10, l=100)
trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])
phenomes = extractphenomes(trials)
# Extract genotype and phenotype data
G::Matrix{Float64} = genomes.allele_frequencies
y::Vector{Float64} = phenomes.phenotypes[:, 1]
# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.
model = turing_bayesGπ(G, y)
# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below
rng::TaskLocalRNG = Random.seed!(123)
niter::Int64 = 1_500
nburnin::Int64 = 500
@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);
# Use the mean paramter values after 150 burn-in iterations
params = Turing.get_params(chain[150:end, :, :]);
b_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);
# Assess prediction accuracy
y_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;
UnicodePlots.scatterplot(y, y_pred)
performance::Dict{String, Float64} = metrics(y, y_pred)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/bayes.jl#L394-L421">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.turing_bayesGπs-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, DynamicPPL.TypeWrap{T}}} where T" href="#GBModels.turing_bayesGπs-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, DynamicPPL.TypeWrap{T}}} where T"><code>GBModels.turing_bayesGπs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Turing specification of Bayesian linear regression using a Gaussian prior with a point mass at zero and varying variances</p><p><strong>Example usage</strong></p><pre><code class="language-julia hljs"># Simulate data
genomes = GBCore.simulategenomes(n=10, l=100)
trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])
phenomes = extractphenomes(trials)
# Extract genotype and phenotype data
G::Matrix{Float64} = genomes.allele_frequencies
y::Vector{Float64} = phenomes.phenotypes[:, 1]
# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.
model = turing_bayesGπs(G, y)
# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below
rng::TaskLocalRNG = Random.seed!(123)
niter::Int64 = 1_500
nburnin::Int64 = 500
@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);
# Use the mean paramter values after 150 burn-in iterations
params = Turing.get_params(chain[150:end, :, :]);
b_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);
# Assess prediction accuracy
y_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;
UnicodePlots.scatterplot(y, y_pred)
performance::Dict{String, Float64} = metrics(y, y_pred)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/bayes.jl#L436-L463">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.turing_bayesL-Tuple{Any, Any}" href="#GBModels.turing_bayesL-Tuple{Any, Any}"><code>GBModels.turing_bayesL</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Turing specification of Bayesian linear regression using a Laplacian prior with a common scale</p><p><strong>Example usage</strong></p><pre><code class="language-julia hljs"># Simulate data
genomes = GBCore.simulategenomes(n=10, l=100)
trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])
phenomes = extractphenomes(trials)
# Extract genotype and phenotype data
G::Matrix{Float64} = genomes.allele_frequencies
y::Vector{Float64} = phenomes.phenotypes[:, 1]
# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.
model = turing_bayesL(G, y)
# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below
rng::TaskLocalRNG = Random.seed!(123)
niter::Int64 = 1_500
nburnin::Int64 = 500
@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);
# Use the mean paramter values after 150 burn-in iterations
params = Turing.get_params(chain[150:end, :, :]);
b_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);
# Assess prediction accuracy
y_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;
UnicodePlots.scatterplot(y, y_pred)
performance::Dict{String, Float64} = metrics(y, y_pred)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/bayes.jl#L482-L509">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.turing_bayesLs-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, DynamicPPL.TypeWrap{T}}} where T" href="#GBModels.turing_bayesLs-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, DynamicPPL.TypeWrap{T}}} where T"><code>GBModels.turing_bayesLs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Turing specification of Bayesian linear regression using a Laplacian prior with varying scales</p><p><strong>Example usage</strong></p><pre><code class="language-julia hljs"># Simulate data
genomes = GBCore.simulategenomes(n=10, l=100)
trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])
phenomes = extractphenomes(trials)
# Extract genotype and phenotype data
G::Matrix{Float64} = genomes.allele_frequencies
y::Vector{Float64} = phenomes.phenotypes[:, 1]
# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.
model = turing_bayesLs(G, y)
# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below
rng::TaskLocalRNG = Random.seed!(123)
niter::Int64 = 1_500
nburnin::Int64 = 500
@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);
# Use the mean paramter values after 150 burn-in iterations
params = Turing.get_params(chain[150:end, :, :]);
b_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);
# Assess prediction accuracy
y_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;
UnicodePlots.scatterplot(y, y_pred)
performance::Dict{String, Float64} = metrics(y, y_pred)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/bayes.jl#L524-L551">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.turing_bayesLπ-Tuple{Any, Any}" href="#GBModels.turing_bayesLπ-Tuple{Any, Any}"><code>GBModels.turing_bayesLπ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Turing specification of Bayesian linear regression using a Laplacian prior with a point mass at zero and common scale</p><p><strong>Example usage</strong></p><pre><code class="language-julia hljs"># Simulate data
genomes = GBCore.simulategenomes(n=10, l=100)
trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])
phenomes = extractphenomes(trials)
# Extract genotype and phenotype data
G::Matrix{Float64} = genomes.allele_frequencies
y::Vector{Float64} = phenomes.phenotypes[:, 1]
# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.
model = turing_bayesLπ(G, y)
# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below
rng::TaskLocalRNG = Random.seed!(123)
niter::Int64 = 1_500
nburnin::Int64 = 500
@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);
# Use the mean paramter values after 150 burn-in iterations
params = Turing.get_params(chain[150:end, :, :]);
b_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);
# Assess prediction accuracy
y_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;
UnicodePlots.scatterplot(y, y_pred)
performance::Dict{String, Float64} = metrics(y, y_pred)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/bayes.jl#L627-L654">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.turing_bayesLπs-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, DynamicPPL.TypeWrap{T}}} where T" href="#GBModels.turing_bayesLπs-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, DynamicPPL.TypeWrap{T}}} where T"><code>GBModels.turing_bayesLπs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Turing specification of Bayesian linear regression using a Laplacian prior with a point mass at zero and common scale</p><p><strong>Example usage</strong></p><pre><code class="language-julia hljs"># Simulate data
genomes = GBCore.simulategenomes(n=10, l=100)
trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])
phenomes = extractphenomes(trials)
# Extract genotype and phenotype data
G::Matrix{Float64} = genomes.allele_frequencies
y::Vector{Float64} = phenomes.phenotypes[:, 1]
# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.
model = turing_bayesLπs(G, y)
# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below
rng::TaskLocalRNG = Random.seed!(123)
niter::Int64 = 1_500
nburnin::Int64 = 500
@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);
# Use the mean paramter values after 150 burn-in iterations
params = Turing.get_params(chain[150:end, :, :]);
b_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);
# Assess prediction accuracy
y_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;
UnicodePlots.scatterplot(y, y_pred)
performance::Dict{String, Float64} = metrics(y, y_pred)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/bayes.jl#L669-L696">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.turing_bayesT-Tuple{Any, Any}" href="#GBModels.turing_bayesT-Tuple{Any, Any}"><code>GBModels.turing_bayesT</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Turing specification of Bayesian linear regression using a T-distribution</p><p><strong>Example usage</strong></p><pre><code class="language-julia hljs"># Simulate data
genomes = GBCore.simulategenomes(n=10, l=100)
trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])
phenomes = extractphenomes(trials)
# Extract genotype and phenotype data
G::Matrix{Float64} = genomes.allele_frequencies
y::Vector{Float64} = phenomes.phenotypes[:, 1]
# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.
model = turing_bayesT(G, y)
# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below
rng::TaskLocalRNG = Random.seed!(123)
niter::Int64 = 1_500
nburnin::Int64 = 500
@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);
# Use the mean paramter values after 150 burn-in iterations
params = Turing.get_params(chain[150:end, :, :]);
b_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);
# Assess prediction accuracy
y_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;
UnicodePlots.scatterplot(y, y_pred)
performance::Dict{String, Float64} = metrics(y, y_pred)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/bayes.jl#L717-L744">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.turing_bayesTπ-Tuple{Any, Any}" href="#GBModels.turing_bayesTπ-Tuple{Any, Any}"><code>GBModels.turing_bayesTπ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Turing specification of Bayesian linear regression using a T-distribution with a point mass at zero</p><p><strong>Example usage</strong></p><pre><code class="language-julia hljs"># Simulate data
genomes = GBCore.simulategenomes(n=10, l=100)
trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])
phenomes = extractphenomes(trials)
# Extract genotype and phenotype data
G::Matrix{Float64} = genomes.allele_frequencies
y::Vector{Float64} = phenomes.phenotypes[:, 1]
# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.
model = turing_bayesTπ(G, y)
# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below
rng::TaskLocalRNG = Random.seed!(123)
niter::Int64 = 1_500
nburnin::Int64 = 500
@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);
# Use the mean paramter values after 150 burn-in iterations
params = Turing.get_params(chain[150:end, :, :]);
b_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);
# Assess prediction accuracy
y_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;
UnicodePlots.scatterplot(y, y_pred)
performance::Dict{String, Float64} = metrics(y, y_pred)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/bayes.jl#L815-L842">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.validate-Tuple{GBCore.Fit, GBCore.Genomes, GBCore.Phenomes}" href="#GBModels.validate-Tuple{GBCore.Fit, GBCore.Genomes, GBCore.Phenomes}"><code>GBModels.validate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">validate(
    fit::Fit,
    genomes::Genomes,
    phenomes::Phenomes;
    idx_validation::Vector{Int64},
    replication::String=&quot;&quot;,
    fold::String=&quot;&quot;
)::CV</code></pre><p>Evaluate the predictive accuracy of a genomic prediction model on a validation dataset.</p><p><strong>Arguments</strong></p><ul><li><code>fit::Fit</code>: A fitted genomic prediction model</li><li><code>genomes::Genomes</code>: Genomic data structure containing allele frequencies</li><li><code>phenomes::Phenomes</code>: Phenotypic data structure containing trait measurements</li><li><code>idx_validation::Vector{Int64}</code>: Indices of entries to use for validation</li><li><code>replication::String</code>: Optional identifier for the validation replication</li><li><code>fold::String</code>: Optional identifier for the cross-validation fold</li></ul><p><strong>Returns</strong></p><ul><li><code>CV</code>: A cross-validation result object containing:<ul><li>Validation metrics (correlation, RMSE, etc.)</li><li>True and predicted values</li><li>Entry and population information</li><li>Model specifications</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>Performs checks for data leakage between training and validation sets</li><li>Handles missing, NaN, and Inf values in phenotypic data</li><li>Validates dimensions of output CV struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);

julia&gt; phenomes = extractphenomes(trials);

julia&gt; fit = ridge(genomes=genomes, phenomes=phenomes, idx_entries=collect(1:90));

julia&gt; cv = validate(fit, genomes, phenomes, idx_validation=collect(91:100));

julia&gt; cv.metrics[&quot;cor&quot;] &gt; 0.50
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/cross_validation.jl#L1-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.@string2operations-Tuple{Any}" href="#GBModels.@string2operations-Tuple{Any}"><code>GBModels.@string2operations</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@string2operations(x)</code></pre><p>Convert a string containing an endofunction formulae for genomic features into a parsed Julia expressions.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: A string containing mathematical operations on allele frequencies</li></ul><p><strong>Returns</strong></p><ul><li>Parsed expression that can be evaluated in Julia</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/e82b3fe89d61645b17d1bad267b943c830855c47/src/transformation.jl#L671-L681">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Sunday 16 March 2025 23:37">Sunday 16 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
